
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  
  <!-- Licensed under the Apache 2.0 License -->
  <link rel="stylesheet" type="text/css" href="../../_static/fonts/open-sans/stylesheet.css" />
  <!-- Licensed under the SIL Open Font License -->
  <link rel="stylesheet" type="text/css" href="../../_static/fonts/source-serif-pro/source-serif-pro.css" />
  <link rel="stylesheet" type="text/css" href="../../_static/css/bootstrap.min.css" />
  <link rel="stylesheet" type="text/css" href="../../_static/css/bootstrap-theme.min.css" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
    <title>7. Grid Coordinates, Elements, and Flow Solution &#8212; CGNS Official Web Site</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/guzzle.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/css/filemap.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/css/math_override.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/css/midlevel.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="shortcut icon" href="../../_static/CGNS_empty.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="8. Multizone Interface Connectivity" href="multizone.html" />
    <link rel="prev" title="6. Hierarchical Structures" href="hierarchy.html" />
  
  <link rel="apple-touch-icon" href="../../_static/CGNS_empty.svg" />
  
   

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="multizone.html" title="8. Multizone Interface Connectivity"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="hierarchy.html" title="6. Hierarchical Structures"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">CGNS Official Web Site</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../standard.html" >Standard Specification</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="CGNS_SIDS.html" accesskey="U">CGNS/SIDS - Standard Interface Data Structures</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">7. </span>Grid Coordinates, Elements, and Flow Solution</a></li> 
      </ul>
    </div>
    <div class="container-wrapper">

      <div id="mobile-toggle">
        <a href="#"><span class="glyphicon glyphicon-align-justify" aria-hidden="true"></span></a>
      </div>
  <div id="left-column">
    <div class="sphinxsidebar">
<div class="sidebar-block">
  <div class="sidebar-wrapper">
    <div id="main-search">
      <form class="form-inline" action="../../search.html" method="GET" role="form">
        <div class="input-group">
          <input name="q" type="text" class="form-control" placeholder="Search...">
        </div>
        <input type="hidden" name="check_keywords" value="yes" />
        <input type="hidden" name="area" value="default" />
      </form>
    </div>
  </div>
</div>
<div class="sidebar-block">
  <div class="sidebar-wrapper">
    <h2>Contents</h2>
    <div class="sidebar-localtoc">
      <ul>
<li><a class="reference internal" href="#">7. Grid Coordinates, Elements, and Flow Solution</a><ul>
<li><a class="reference internal" href="#grid-coordinates-structure-definition-gridcoordinates-t">7.1. Grid Coordinates Structure Definition: <code class="code sidskey docutils literal notranslate"><span class="pre">GridCoordinates_t</span></code></a></li>
<li><a class="reference internal" href="#grid-coordinates-examples">7.2. Grid Coordinates Examples</a><ul>
<li><a class="reference internal" href="#example-cartesian-coordinates-for-a-2-d-structured-grid">7.2.1. Example - Cartesian Coordinates for a 2-D Structured Grid</a></li>
<li><a class="reference internal" href="#example-cylindrical-coordinates-for-a-3-d-structured-grid">7.2.2. Example - Cylindrical Coordinates for a 3-D Structured Grid</a></li>
<li><a class="reference internal" href="#example-cartesian-coordinates-for-a-3-d-unstructured-grid">7.2.3. Example - Cartesian Coordinates for a 3-D Unstructured Grid</a></li>
</ul>
</li>
<li><a class="reference internal" href="#elements-structure-definition-elements-t">7.3. Elements Structure Definition: <code class="docutils literal notranslate"><span class="pre">Elements_t</span></code></a></li>
<li><a class="reference internal" href="#elements-examples">7.4. Elements Examples</a><ul>
<li><a class="reference internal" href="#example-tetra-4-element-types">7.4.1. Example - TETRA_4 Element Types</a></li>
<li><a class="reference internal" href="#example-ngon-n-and-nface-n-element-types">7.4.2. Example - NGON_n and NFACE_n Element Types</a></li>
<li><a class="reference internal" href="#example-separate-element-types">7.4.3. Example - Separate Element Types</a></li>
<li><a class="reference internal" href="#example-mixed-element-type">7.4.4. Example - MIXED Element Type</a></li>
</ul>
</li>
<li><a class="reference internal" href="#axisymmetry-structure-definition-axisymmetry-t">7.5. Axisymmetry Structure Definition: <code class="docutils literal notranslate"><span class="pre">Axisymmetry_t</span></code></a></li>
<li><a class="reference internal" href="#rotating-coordinates-structure-definition-rotatingcoordinates-t">7.6. Rotating Coordinates Structure Definition: <code class="docutils literal notranslate"><span class="pre">RotatingCoordinates_t</span></code></a></li>
<li><a class="reference internal" href="#flow-solution-structure-definition-flowsolution-t">7.7. Flow Solution Structure Definition: <code class="code sidskey docutils literal notranslate"><span class="pre">FlowSolution_t</span></code></a></li>
<li><a class="reference internal" href="#flow-solution-example">7.8. Flow Solution Example</a><ul>
<li><a class="reference internal" href="#example-flow-solution">7.8.1. Example - Flow Solution</a></li>
</ul>
</li>
<li><a class="reference internal" href="#zone-subregion-structure-definition-zonesubregion-t">7.9. Zone Subregion Structure Definition: <code class="docutils literal notranslate"><span class="pre">ZoneSubRegion_t</span></code></a></li>
<li><a class="reference internal" href="#zone-subregion-examples">7.10. Zone Subregion Examples</a><ul>
<li><a class="reference internal" href="#example-volume-subregion-for-a-structured-grid">7.10.1. Example - Volume Subregion for a Structured Grid</a></li>
<li><a class="reference internal" href="#example-volume-subregion-for-an-unstructured-grid">7.10.2. Example - Volume Subregion for an Unstructured Grid</a></li>
<li><a class="reference internal" href="#example-surface-subregion-for-an-unstructured-grid">7.10.3. Example - Surface Subregion for an Unstructured Grid</a></li>
<li><a class="reference internal" href="#example-surface-subregion-utilizing-bc-information">7.10.4. Example - Surface Subregion Utilizing BC Information</a></li>
</ul>
</li>
</ul>
</li>
</ul>

    </div>
  </div>
</div>
      
    </div>
  </div>
        <div id="right-column">
          
          <div role="navigation" aria-label="breadcrumbs navigation">
            <ol class="breadcrumb">
              <li><a href="../../index.html">Docs</a></li>
              
                <li><a href="../../standard.html">Standard Specification</a></li>
              
                <li><a href="CGNS_SIDS.html">CGNS/SIDS - Standard Interface Data Structures</a></li>
              
              <li><span class="section-number">7. </span>Grid Coordinates, Elements, and Flow Solution</li>
            </ol>
          </div>
          
          <div class="document clearer body">
            
  <section id="grid-coordinates-elements-and-flow-solution">
<h1><span class="section-number">7. </span>Grid Coordinates, Elements, and Flow Solution<a class="headerlink" href="#grid-coordinates-elements-and-flow-solution" title="Permalink to this headline">¶</a></h1>
<p>This section defines structure types for describing the grid coordinates, element data, and flow solution data pertaining to a zone. Entities of each of the structure types defined in this section are contained in the <code class="code sidsref docutils literal notranslate"><span class="pre">Zone_t</span></code> structure.</p>
<section id="grid-coordinates-structure-definition-gridcoordinates-t">
<span id="gridcoordinates-t"></span><h2><span class="section-number">7.1. </span>Grid Coordinates Structure Definition: <code class="code sidskey docutils literal notranslate"><span class="pre">GridCoordinates_t</span></code><a class="headerlink" href="#grid-coordinates-structure-definition-gridcoordinates-t" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>The physical coordinates of the grid vertices are described by the <code class="code sidskey docutils literal notranslate"><span class="pre">GridCoordinates_t</span></code> structure. This structure contains a list for the data arrays of the individual components of the position vector. It also provides a mechanism for identifying rind-point data included within the position-vector arrays.</p>
</div></blockquote>
<div class="highlight-sids notranslate"><div class="highlight"><pre><span></span><span class="kt">GridCoordinates_t</span><span class="o">&lt;</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">IndexDimension</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">VertexSize</span><span class="p">[</span><span class="n">IndexDimension</span><span class="p">],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">PhysicalDimension</span><span class="o">&gt;</span><span class="w"> </span><span class="o">:=</span><span class="w"></span>
<span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kt">DataArray_t</span><span class="o">&lt;</span><span class="n">DataType</span><span class="p">,</span><span class="w"> </span><span class="n">PhysicalDimension</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">BoundingBox</span><span class="w"> </span><span class="p">;</span><span class="w">          </span><span class="kr">(o)</span><span class="w"></span>

<span class="w">   </span><span class="k">List</span><span class="p">(</span><span class="w"> </span><span class="kt">Descriptor_t</span><span class="w"> </span><span class="n">Descriptor1</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">DescriptorN</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w">                 </span><span class="kr">(o)</span><span class="w"></span>

<span class="w">   </span><span class="kt">Rind_t</span><span class="o">&lt;</span><span class="n">IndexDimension</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Rind</span><span class="w"> </span><span class="p">;</span><span class="w">                                      </span><span class="kr">(o/d)</span><span class="w"></span>

<span class="w">   </span><span class="k">List</span><span class="p">(</span><span class="w"> </span><span class="kt">DataArray_t</span><span class="o">&lt;</span><span class="n">DataType</span><span class="p">,</span><span class="w"> </span><span class="n">IndexDimension</span><span class="p">,</span><span class="w"> </span><span class="n">DataSize</span><span class="p">[]</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">         </span><span class="n">DataArray1</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">DataArrayN</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w">                                </span><span class="kr">(o)</span><span class="w"></span>

<span class="w">   </span><span class="kt">DataClass_t</span><span class="w"> </span><span class="n">DataClass</span><span class="w"> </span><span class="p">;</span><span class="w">                                            </span><span class="kr">(o)</span><span class="w"></span>

<span class="w">   </span><span class="kt">DimensionalUnits_t</span><span class="w"> </span><span class="n">DimensionalUnits</span><span class="w"> </span><span class="p">;</span><span class="w">                              </span><span class="kr">(o)</span><span class="w"></span>

<span class="w">   </span><span class="k">List</span><span class="p">(</span><span class="w"> </span><span class="kt">UserDefinedData_t</span><span class="w"> </span><span class="n">UserDefinedData1</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">UserDefinedDataN</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w">  </span><span class="kr">(o)</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ol class="arabic simple">
<li><p>Default names for the <code class="code sidsref docutils literal notranslate"><span class="pre">Descriptor_t</span></code>, <code class="code sidsref docutils literal notranslate"><span class="pre">DataArray_t</span></code>, and <code class="code sidsref docutils literal notranslate"><span class="pre">UserDefinedData_t</span></code> lists are as shown; users may choose other legitimate names. Legitimate names must be unique within a given instance of GridCoordinates_t and shall not include the names <code class="code sidskey docutils literal notranslate"><span class="pre">DataClass</span></code>, <code class="code sidskey docutils literal notranslate"><span class="pre">DimensionalUnits</span></code>, or <code class="code sidskey docutils literal notranslate"><span class="pre">Rind</span></code>.</p></li>
<li><p>There are no required fields for <code class="code sidskey docutils literal notranslate"><span class="pre">GridCoordinates_t</span></code>. <code class="code sidsref docutils literal notranslate"><span class="pre">Rind</span></code> has a default if absent; the default is equivalent to having a <code class="code sidskey docutils literal notranslate"><span class="pre">Rind</span></code> structure whose <code class="code sidskey docutils literal notranslate"><span class="pre">RindPlanes</span></code> array contains all zeros.</p></li>
<li><p>The structure parameter DataType must be consistent with the data stored in the <code class="code sidsref docutils literal notranslate"><span class="pre">DataArray_t</span></code> substructures.</p></li>
</ol>
</div>
<p><code class="code sidskey docutils literal notranslate"><span class="pre">GridCoordinates_t</span></code> requires two structure parameters: <code class="code sidskey docutils literal notranslate"><span class="pre">IndexDimension</span></code> identifies the dimensionality of the grid-size arrays, and <code class="code sidskey docutils literal notranslate"><span class="pre">VertexSize</span></code> is the number of vertices in each index direction excluding rind points. For unstructured zones, <code class="code sidskey docutils literal notranslate"><span class="pre">IndexDimension</span></code> is always 1 and <code class="code sidskey docutils literal notranslate"><span class="pre">VertexSize</span></code> is the total number of vertices, excluding rind points.</p>
<p>The grid-coordinates data is stored in the list of <code class="code sidskey docutils literal notranslate"><span class="pre">DataArray_t</span></code> entities; each <code class="code sidskey docutils literal notranslate"><span class="pre">DataArray_t</span></code> structure entity may contain a single component of the position vector (e.g., three separate <code class="code sidskey docutils literal notranslate"><span class="pre">DataArray_t</span></code> entities are used for x, y, and z).</p>
<p>Standardized data-name identifiers for the grid coordinates are described in <span class="xref std std-ref">Conventions for Data-Name Identifiers</span>.</p>
<p><code class="code sidskey docutils literal notranslate"><span class="pre">Rind</span></code> is an optional field that indicates the number of rind planes (for structured grids) or rind points (for unstructured grids) included in the grid-coordinates data. If <code class="code sidskey docutils literal notranslate"><span class="pre">Rind</span></code> is absent, then the <code class="code sidskey docutils literal notranslate"><span class="pre">DataArray_t</span></code> structure entities contain only “core” vertices of a zone; core refers to all interior and bounding vertices of a zone - <code class="code sidskey docutils literal notranslate"><span class="pre">VertexSize</span></code> is the number of core vertices. Core vertices in a zone begin at [1,1,1] (for a structured zone in 3-D) and end at <code class="code sidskey docutils literal notranslate"><span class="pre">VertexSize</span></code>. If <code class="code sidskey docutils literal notranslate"><span class="pre">Rind</span></code> is present, it will provide information on the number of “rind” points in addition to the core points that are contained in the <code class="code sidskey docutils literal notranslate"><span class="pre">DataArray_t</span></code> structures. Indices in <code class="code sidskey docutils literal notranslate"><span class="pre">DataArray_t</span></code> structures have the range <span class="math notranslate nohighlight">\([1 - a,1 - c,1 - e]\)</span> to <span class="math notranslate nohighlight">\([II + b,JJ + d,KK + f]\)</span> where <code class="code docutils literal notranslate"><span class="pre">VertexSize</span> <span class="pre">=</span> <span class="pre">[II,JJ,...]</span></code> and <code class="code docutils literal notranslate"><span class="pre">RindPlanes</span> <span class="pre">=</span> <span class="pre">[a,b,...]</span></code> (see the <code class="code sidsref docutils literal notranslate"><span class="pre">Rind_t</span></code> structure for the definition of <code class="code sidskey docutils literal notranslate"><span class="pre">RindPlanes</span></code>).</p>
<p><code class="code sidsref docutils literal notranslate"><span class="pre">DataClass</span></code> defines the default class for data contained in the <code class="code sidsref docutils literal notranslate"><span class="pre">DataArray_t</span></code> entities. For dimensional grid coordinates, <code class="code sidsref docutils literal notranslate"><span class="pre">DimensionalUnits</span></code> may be used to describe the system of units employed. If present, these two entities take precedence over the corresponding entities at higher levels of the CGNS hierarchy, following the standard <a class="reference internal" href="hierarchy.html#precedence"><span class="std std-ref">precedence rules</span></a>. An example that uses these grid-coordinate defaults is shown under <a class="reference internal" href="#grid-example"><span class="std std-ref">Grid Coordinates Examples</span></a>.</p>
<p>The <code class="code sidsref docutils literal notranslate"><span class="pre">UserDefinedData_t</span></code> data structure allows arbitrary user-defined data to be stored in <code class="code sidskey docutils literal notranslate"><span class="pre">Descriptor_t</span></code> and <code class="code sidskey docutils literal notranslate"><span class="pre">DataArray_t</span></code> children without the restrictions or implicit meanings imposed on these node types at other node locations.</p>
<p>The <code class="code sidskey docutils literal notranslate"><span class="pre">BoundingBox</span></code> array is optional and provides a measure within which all the grid points lie. It stores minima and maxima of Coordinates values sorted by alphabetical order for Cartesian and Cylindrical coordinate systems while Spherical and Auxiliary coordinate systems retain a specific order to be coherent with the existing SIDS notation:</p>
<table class="docutils align-center" style="width: 400px">
<colgroup>
<col style="width: 18%" />
<col style="width: 82%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>System</p></th>
<th class="head"><p>Bounding Box</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Cartesian 3-D</p></td>
<td><div class="math notranslate nohighlight">
\[\begin{split}[[Min(CoordinateX), Min(CoordinateY), Min(CoordinateZ)], \\
 [Max(CoordinateX), Max(CoordinateY), Max(CoordinateZ)]]\end{split}\]</div>
</td>
</tr>
<tr class="row-odd"><td><p>Cylindrical 3-D</p></td>
<td><div class="math notranslate nohighlight">
\[\begin{split}[[Min(CoordinateR), Inf(CoordinateTheta), Min(CoordinateX)], \\
 [Max(CoordinateR), Sup(CoordinateTheta), Max(CoordinateX)]]\end{split}\]</div>
<p>or</p>
<div class="math notranslate nohighlight">
\[\begin{split}[[Min(CoordinateR), Inf(CoordinateTheta), Min(CoordinateY)], \\
 [Max(CoordinateR), Sup(CoordinateTheta), Max(CoordinateY)]]\end{split}\]</div>
<p>or</p>
<div class="math notranslate nohighlight">
\[\begin{split}[[Min(CoordinateR), Inf(CoordinateTheta), Min(CoordinateZ)], \\
 [Max(CoordinateR), Sup(CoordinateTheta), Max(CoordinateZ)]]\end{split}\]</div>
</td>
</tr>
<tr class="row-even"><td><p>Spherical</p></td>
<td><div class="math notranslate nohighlight">
\[\begin{split}[[Min(CoordinateR), Inf(CoordinateTheta), Inf(CoordinatePhi)], \\
 [Max(CoordinateR), Sup(CoordinateTheta), Sup(CoordinatePhi)]]\end{split}\]</div>
</td>
</tr>
<tr class="row-odd"><td><p>Auxiliary 3-D</p></td>
<td><div class="math notranslate nohighlight">
\[\begin{split}[[Min(CoordinateXi), Min(CoordinateEta), Min(CoordinateZeta)], \\
 [Max(CoordinateXi), Max(CoordinateEta), Max(CoordinateZeta)]]\end{split}\]</div>
</td>
</tr>
</tbody>
</table>
<p>Thus, all coordinate systems are handled in a deterministic way. For 2-D coordinate system, the order is kept the same as for 3-D.
Angle coordinate part of a bounding box is defined by <span class="math notranslate nohighlight">\(Inf(CoordinateTheta)\)</span> and <span class="math notranslate nohighlight">\(Sup(CoordinateTheta)\)</span> (respectively <span class="math notranslate nohighlight">\(Inf(CoordinatePhi)\)</span> and <span class="math notranslate nohighlight">\(Sup(CoordinatePhi)\)</span> for spherical coordinate angle) where <span class="math notranslate nohighlight">\(Inf\)</span> and <span class="math notranslate nohighlight">\(Sup\)</span> operators ensure unicity of the angle interval. The constraints for valid angle bounding box limits are:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(Inf(CoordinateTheta)\)</span> is included in <span class="math notranslate nohighlight">\([0; 2 π]\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(Inf(CoordinateTheta) &lt; Sup(CoordinateTheta)\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(Sup(CoordinateTheta) - Inf(CoordinateTheta) ≤ 2 π\)</span></p></li>
</ul>
<span class="target" id="datasize-grid"></span><dl class="c function">
<dt class="sig sig-object c" id="c.DataSize">
<span class="n"><span class="pre">FUNCTION</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">DataSize</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.DataSize" title="Permalink to this definition">¶</a><br /></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return value</dt>
<dd class="field-odd"><p>one-dimensional <code class="docutils literal notranslate"><span class="pre">int</span></code> array of length <code class="code sidskey docutils literal notranslate"><span class="pre">IndexDimension</span></code></p>
</dd>
<dt class="field-even">Dependencies</dt>
<dd class="field-even"><p><code class="code sidskey docutils literal notranslate"><span class="pre">IndexDimension</span></code>, <code class="code sidskey docutils literal notranslate"><span class="pre">VertexSize[]</span></code>, <code class="code sidskey docutils literal notranslate"><span class="pre">Rind</span></code></p>
</dd>
</dl>
<p><code class="code sidskey docutils literal notranslate"><span class="pre">GridCoordinates_t</span></code> requires a single structure function, named <code class="code sidskey docutils literal notranslate"><span class="pre">DataSize</span></code>, to identify the array sizes of the grid-coordinates data. A function is required for the following reasons:</p>
<blockquote>
<div><ul class="simple">
<li><p>the entire grid, including both core and rind points, is stored in the <code class="code sidsref docutils literal notranslate"><span class="pre">DataArray_t</span></code> entities;</p></li>
<li><p>the <code class="code sidskey docutils literal notranslate"><span class="pre">DataArray_t</span></code> structure is simple in that it doesn’t know anything about core versus rind data; it just knows that it contains data of some given size;</p></li>
<li><p>to make all the <code class="code sidskey docutils literal notranslate"><span class="pre">DataArray_t</span></code> entities syntactically consistent in their size (i.e., by syntax entities containing x, y and z must have the same dimensionality and dimension sizes), the size of the array is passed onto the <code class="code sidskey docutils literal notranslate"><span class="pre">DataArray_t</span></code> structure as a parameter.</p></li>
</ul>
</div></blockquote>
<div class="highlight-sids notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Rind</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">absent</span><span class="p">)</span><span class="w"> </span><span class="n">then</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">DataSize</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VertexSize</span><span class="p">[]</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Rind</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">present</span><span class="p">)</span><span class="w"> </span><span class="n">then</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">DataSize</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VertexSize</span><span class="p">[]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">,...]</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>where <code class="code docutils literal notranslate"><span class="pre">RindPlanes</span> <span class="pre">=</span> <span class="pre">[a,b,...]</span></code> (see the <code class="code sidsref docutils literal notranslate"><span class="pre">Rind_t</span></code> structure for the definition of <code class="code sidskey docutils literal notranslate"><span class="pre">RindPlanes</span></code>).</p>
</dd></dl>

</section>
<section id="grid-coordinates-examples">
<span id="grid-example"></span><h2><span class="section-number">7.2. </span>Grid Coordinates Examples<a class="headerlink" href="#grid-coordinates-examples" title="Permalink to this headline">¶</a></h2>
<p>This section contains examples of grid coordinates. These examples show the storage of the grid-coordinate data arrays, as well as different mechanisms for describing the class of data and the system of units or normalization.</p>
<section id="example-cartesian-coordinates-for-a-2-d-structured-grid">
<h3><span class="section-number">7.2.1. </span>Example - Cartesian Coordinates for a 2-D Structured Grid<a class="headerlink" href="#example-cartesian-coordinates-for-a-2-d-structured-grid" title="Permalink to this headline">¶</a></h3>
<p>This example uses Cartesian coordinates for a 2-D grid of size 17 × 33; the data arrays include only core vertices, and the coordinates are in units of feet.</p>
<div class="highlight-sids notranslate"><div class="highlight"><pre><span></span><span class="c1">!  IndexDimension = 2</span>
<span class="c1">!  VertexSize = [17,33]</span>
<span class="kt">GridCoordinates_t</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="mi">17</span><span class="p">,</span><span class="mi">33</span><span class="p">]</span><span class="o">&gt;</span><span class="w"> </span><span class="n">GridCoordinates</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">  </span><span class="p">{{</span><span class="w"></span>
<span class="w">  </span><span class="kt">DataArray_t</span><span class="o">&lt;</span><span class="kt">real</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="mi">17</span><span class="p">,</span><span class="mi">33</span><span class="p">]</span><span class="o">&gt;</span><span class="w"> </span><span class="n">CoordinateX</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="p">{{</span><span class="w"></span>
<span class="w">    </span><span class="k">Data</span><span class="p">(</span><span class="kt">real</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="mi">17</span><span class="p">,</span><span class="mi">33</span><span class="p">])</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="n">x</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">),</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="mi">17</span><span class="p">),</span><span class="w"> </span><span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="mi">33</span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kt">DataClass_t</span><span class="w"> </span><span class="n">DataClass</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Dimensional</span><span class="w"> </span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kt">DimensionalUnits_t</span><span class="w"> </span><span class="n">DimensionalUnits</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">      </span><span class="p">{{</span><span class="w"></span>
<span class="w">      </span><span class="n">MassUnits</span><span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="n">MassUnitsNull</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">LengthUnits</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">Foot</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">TimeUnits</span><span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="n">TimeUnitsNull</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">TemperatureUnits</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TemperatureUnitsNull</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">AngleUnits</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="n">AngleUnitsNull</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="kt">DataArray_t</span><span class="o">&lt;</span><span class="kt">real</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="mi">17</span><span class="p">,</span><span class="mi">33</span><span class="p">]</span><span class="o">&gt;</span><span class="w"> </span><span class="n">CoordinateY</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="p">{{</span><span class="w"></span>
<span class="w">    </span><span class="k">Data</span><span class="p">(</span><span class="kt">real</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="mi">17</span><span class="p">,</span><span class="mi">33</span><span class="p">])</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="n">y</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">),</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="mi">17</span><span class="p">),</span><span class="w"> </span><span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="mi">33</span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kt">DataClass_t</span><span class="w"> </span><span class="n">DataClass</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Dimensional</span><span class="w"> </span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kt">DimensionalUnits_t</span><span class="w"> </span><span class="n">DimensionalUnits</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">      </span><span class="p">{{</span><span class="w"></span>
<span class="w">      </span><span class="n">MassUnits</span><span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="n">MassUnitsNull</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">LengthUnits</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">Foot</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">TimeUnits</span><span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="n">TimeUnitsNull</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">TemperatureUnits</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TemperatureUnitsNull</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">AngleUnits</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="n">AngleUnitsNull</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>From the <a class="reference internal" href="appendix_a.html#dataname"><span class="std std-ref">Conventions for Data-Name Identifiers</span></a>, the identifiers for <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> are <code class="code sidskey docutils literal notranslate"><span class="pre">CoordinateX</span></code> and <code class="code sidskey docutils literal notranslate"><span class="pre">CoordinateY</span></code>, respectively, and both have a data type of <code class="code sidskey docutils literal notranslate"><span class="pre">real</span></code>. The value of <code class="code sidsref docutils literal notranslate"><span class="pre">DataClass</span></code> in <code class="code sidskey docutils literal notranslate"><span class="pre">CoordinateX</span></code> and <code class="code sidskey docutils literal notranslate"><span class="pre">CoordinateY</span></code> indicate the data is dimensional, and <code class="code sidsref docutils literal notranslate"><span class="pre">DimensionalUnits</span></code> specifies the appropriate units are feet. The <code class="code sidsref docutils literal notranslate"><span class="pre">DimensionalExponents</span></code> entity is absent from both <code class="code sidskey docutils literal notranslate"><span class="pre">CoordinateX</span></code> and <code class="code sidskey docutils literal notranslate"><span class="pre">CoordinateY</span></code>; the information that <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> are lengths can be inferred from the <span class="xref std std-ref">data-name identifier conventions for coordinate systems</span>.</p>
<p>Note that FORTRAN multidimensional array indexing is used to store the data; this is reflected in the FORTRAN-like implied do-loops for <code class="code docutils literal notranslate"><span class="pre">x(i,j)</span></code> and <code class="code docutils literal notranslate"><span class="pre">y(i,j)</span></code>.</p>
<p>Because the dimensional units for both <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> are the same, an alternate approach is to set the data class and system of units using <code class="code sidsref docutils literal notranslate"><span class="pre">DataClass</span></code> and <code class="code sidsref docutils literal notranslate"><span class="pre">DimensionalUnits</span></code> at the <code class="code sidsref docutils literal notranslate"><span class="pre">GridCoordinates_t</span></code> level, and eliminate this information from each instance of <code class="code sidsref docutils literal notranslate"><span class="pre">DataArray_t</span></code>.</p>
<div class="highlight-sids notranslate"><div class="highlight"><pre><span></span><span class="kt">GridCoordinates_t</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="mi">17</span><span class="p">,</span><span class="mi">33</span><span class="p">]</span><span class="o">&gt;</span><span class="w"> </span><span class="n">GridCoordinates</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">  </span><span class="p">{{</span><span class="w"></span>
<span class="w">  </span><span class="kt">DataClass_t</span><span class="w"> </span><span class="n">DataClass</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Dimensional</span><span class="w"> </span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="kt">DimensionalUnits_t</span><span class="w"> </span><span class="n">DimensionalUnits</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="p">{{</span><span class="w"></span>
<span class="w">    </span><span class="n">MassUnits</span><span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="n">MassUnitsNull</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">LengthUnits</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">Foot</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">TimeUnits</span><span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="n">TimeUnitsNull</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">TemperatureUnits</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TemperatureUnitsNull</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">AngleUnits</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="n">AngleUnitsNull</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="kt">DataArray_t</span><span class="o">&lt;</span><span class="kt">real</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="mi">17</span><span class="p">,</span><span class="mi">33</span><span class="p">]</span><span class="o">&gt;</span><span class="w"> </span><span class="n">CoordinateX</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="p">{{</span><span class="w"></span>
<span class="w">    </span><span class="k">Data</span><span class="p">(</span><span class="kt">real</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="mi">17</span><span class="p">,</span><span class="mi">33</span><span class="p">])</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="n">x</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">),</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="mi">17</span><span class="p">),</span><span class="w"> </span><span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="mi">33</span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="kt">DataArray_t</span><span class="o">&lt;</span><span class="kt">real</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="mi">17</span><span class="p">,</span><span class="mi">33</span><span class="p">]</span><span class="o">&gt;</span><span class="w"> </span><span class="n">CoordinateY</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="p">{{</span><span class="w"></span>
<span class="w">    </span><span class="k">Data</span><span class="p">(</span><span class="kt">real</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="mi">17</span><span class="p">,</span><span class="mi">33</span><span class="p">])</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="n">y</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">),</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="mi">17</span><span class="p">),</span><span class="w"> </span><span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="mi">33</span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>Since the <code class="code sidsref docutils literal notranslate"><span class="pre">DataClass</span></code> and <code class="code sidsref docutils literal notranslate"><span class="pre">DimensionalUnits</span></code> entities are not present in <code class="code sidskey docutils literal notranslate"><span class="pre">CoordinateX</span></code> and <code class="code sidskey docutils literal notranslate"><span class="pre">CoordinateY</span></code>, the established rules for dimensional data dictate that <code class="code sidskey docutils literal notranslate"><span class="pre">DataClass</span></code> and <code class="code sidskey docutils literal notranslate"><span class="pre">DimensionalUnits</span></code> specified at the <code class="code sidsref docutils literal notranslate"><span class="pre">GridCoordinates_t</span></code> level be used to retrieve the information.</p>
</section>
<section id="example-cylindrical-coordinates-for-a-3-d-structured-grid">
<h3><span class="section-number">7.2.2. </span>Example - Cylindrical Coordinates for a 3-D Structured Grid<a class="headerlink" href="#example-cylindrical-coordinates-for-a-3-d-structured-grid" title="Permalink to this headline">¶</a></h3>
<p>This example uses cylindrical coordinates for a 3-D grid whose core size is 17 × 33 × 9; the grid contains a single plane of rind on the minimum and maximum k faces. The coordinates are nondimensional.</p>
<div class="highlight-sids notranslate"><div class="highlight"><pre><span></span><span class="c1">!  IndexDimension = 3</span>
<span class="c1">!  VertexSize = [17,33,9]</span>
<span class="kt">GridCoordinates_t</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="mi">17</span><span class="p">,</span><span class="mi">33</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span><span class="o">&gt;</span><span class="w"> </span><span class="n">GridCoordinates</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">  </span><span class="p">{{</span><span class="w"></span>
<span class="w">  </span><span class="kt">Rind_t</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Rind</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="p">{{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="w"> </span><span class="n">RindPlanes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">! DataType = real</span>
<span class="w">  </span><span class="c1">! IndexDimension = 3</span>
<span class="w">  </span><span class="c1">! DataSize = VertexSize + [0,0,2] = [17,33,11]</span>
<span class="w">  </span><span class="kt">DataArray_t</span><span class="o">&lt;</span><span class="kt">real</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="mi">17</span><span class="p">,</span><span class="mi">33</span><span class="p">,</span><span class="mi">11</span><span class="p">]</span><span class="o">&gt;</span><span class="w"> </span><span class="n">CoordinateRadius</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="p">{{</span><span class="w"></span>
<span class="w">    </span><span class="k">Data</span><span class="p">(</span><span class="kt">real</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="mi">17</span><span class="p">,</span><span class="mi">33</span><span class="p">,</span><span class="mi">11</span><span class="p">])</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(((</span><span class="n">r</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">),</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="mi">17</span><span class="p">),</span><span class="w"> </span><span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="mi">33</span><span class="p">),</span><span class="w"> </span><span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kt">DataClass_t</span><span class="w"> </span><span class="n">DataClass</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NormalizedByUnknownDimensional</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="kt">DataArray_t</span><span class="o">&lt;</span><span class="kt">real</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="mi">17</span><span class="p">,</span><span class="mi">33</span><span class="p">,</span><span class="mi">11</span><span class="p">]</span><span class="o">&gt;</span><span class="w"> </span><span class="n">CoordinateZ</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="p">{{</span><span class="w"> </span><span class="p">}}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">DataArray_t</span><span class="o">&lt;</span><span class="kt">real</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="mi">17</span><span class="p">,</span><span class="mi">33</span><span class="p">,</span><span class="mi">11</span><span class="p">]</span><span class="o">&gt;</span><span class="w"> </span><span class="n">CoordinateTheta</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{{</span><span class="w"> </span><span class="p">}}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>The value of <code class="code sidskey docutils literal notranslate"><span class="pre">RindPlanes</span></code> specifies two rind planes on the minimum and maximum k faces. These rind planes are reflected in the structure function <code class="code sidsref docutils literal notranslate"><span class="pre">DataSize</span></code> which is equal to the number of core vertices plus two in the k dimension. The value of <code class="code sidskey docutils literal notranslate"><span class="pre">DataSize</span></code> is passed to the <code class="code sidsref docutils literal notranslate"><span class="pre">DataArray_t</span></code> entities. The value of <code class="code sidsref docutils literal notranslate"><span class="pre">DataClass</span></code> indicates the data is nondimensional. Note that if <code class="code sidskey docutils literal notranslate"><span class="pre">DataClass</span></code> is set as <code class="code sidskey docutils literal notranslate"><span class="pre">NormalizedByUnknownDimensional</span></code> at a higher level (<code class="code sidsref docutils literal notranslate"><span class="pre">CGNSBase_t</span></code> or <code class="code sidsref docutils literal notranslate"><span class="pre">Zone_t</span></code>), then it is not needed here.</p>
<p>Note that the entities <code class="code sidskey docutils literal notranslate"><span class="pre">CoordinateZ</span></code> and <code class="code sidskey docutils literal notranslate"><span class="pre">CoordinateTheta</span></code> are abbreviated.</p>
</section>
<section id="example-cartesian-coordinates-for-a-3-d-unstructured-grid">
<h3><span class="section-number">7.2.3. </span>Example - Cartesian Coordinates for a 3-D Unstructured Grid<a class="headerlink" href="#example-cartesian-coordinates-for-a-3-d-unstructured-grid" title="Permalink to this headline">¶</a></h3>
<p>This example uses Cartesian grid coordinates for a 3-D unstructured zone where <code class="code sidskey docutils literal notranslate"><span class="pre">VertexSize</span></code> is 15.</p>
<div class="highlight-sids notranslate"><div class="highlight"><pre><span></span><span class="kt">GridCoordinates_t</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">15</span><span class="o">&gt;</span><span class="w"> </span><span class="n">GridCoordinates</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">  </span><span class="p">{{</span><span class="w"></span>

<span class="w">  </span><span class="c1">! DataType = real</span>
<span class="w">  </span><span class="c1">! IndexDimension = 1</span>
<span class="w">  </span><span class="c1">! DataSize = VertexSize = 15</span>
<span class="w">  </span><span class="kt">DataArray_t</span><span class="o">&lt;</span><span class="kt">real</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">15</span><span class="o">&gt;</span><span class="w"> </span><span class="n">CoordinateX</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="p">{{</span><span class="w"></span>
<span class="w">    </span><span class="k">Data</span><span class="p">(</span><span class="kt">real</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">15</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">(</span><span class="n">i</span><span class="p">),</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="mi">15</span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="kt">DataArray_t</span><span class="o">&lt;</span><span class="kt">real</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">15</span><span class="o">&gt;</span><span class="w"> </span><span class="n">CoordinateY</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="p">{{</span><span class="w"></span>
<span class="w">    </span><span class="k">Data</span><span class="p">(</span><span class="kt">real</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">15</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">y</span><span class="p">(</span><span class="n">i</span><span class="p">),</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="mi">15</span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="kt">DataArray_t</span><span class="o">&lt;</span><span class="kt">real</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">15</span><span class="o">&gt;</span><span class="w"> </span><span class="n">CoordinateZ</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="p">{{</span><span class="w"></span>
<span class="w">    </span><span class="k">Data</span><span class="p">(</span><span class="kt">real</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">15</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">z</span><span class="p">(</span><span class="n">i</span><span class="p">),</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="mi">15</span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="elements-structure-definition-elements-t">
<h2><span class="section-number">7.3. </span>Elements Structure Definition: <code class="docutils literal notranslate"><span class="pre">Elements_t</span></code><a class="headerlink" href="#elements-structure-definition-elements-t" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>The <code class="code sidskey docutils literal notranslate"><span class="pre">Elements_t</span></code> data structure is required for unstructured zones, and contains the element connectivity data, the element type, the element range, the parent elements data, and the number of boundary elements.</p>
</div></blockquote>
<div class="highlight-sids notranslate"><div class="highlight"><pre><span></span><span class="kt">Elements_t</span><span class="w"> </span><span class="o">:=</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">List</span><span class="p">(</span><span class="w"> </span><span class="kt">Descriptor_t</span><span class="w"> </span><span class="n">Descriptor1</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">DescriptorN</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w">                 </span><span class="kr">(o)</span><span class="w"></span>

<span class="w">  </span><span class="kt">Rind_t</span><span class="o">&lt;</span><span class="n">IndexDimension</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Rind</span><span class="w"> </span><span class="p">;</span><span class="w">                                      </span><span class="kr">(o/d)</span><span class="w"></span>

<span class="w">  </span><span class="kt">IndexRange_t</span><span class="w"> </span><span class="n">ElementRange</span><span class="w"> </span><span class="p">;</span><span class="w">                                        </span><span class="kr">(r)</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">ElementSizeBoundary</span><span class="w"> </span><span class="p">;</span><span class="w">                                          </span><span class="kr">(o/d)</span><span class="w"></span>

<span class="w">  </span><span class="kt">ElementType_t</span><span class="w"> </span><span class="n">ElementType</span><span class="w"> </span><span class="p">;</span><span class="w">                                        </span><span class="kr">(r)</span><span class="w"></span>

<span class="w">  </span><span class="kt">DataArray_t</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">ElementDataSize</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ElementConnectivity</span><span class="w"> </span><span class="p">;</span><span class="w">         </span><span class="kr">(r)</span><span class="w"></span>
<span class="w">  </span><span class="kt">DataArray_t</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">ElementSize</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ElementStartOffset</span><span class="w"> </span><span class="p">;</span><span class="w">          </span><span class="kr">(r)</span><span class="w"></span>

<span class="w">  </span><span class="kt">DataArray_t</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">ElementSize</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ParentElements</span><span class="p">;</span><span class="w">              </span><span class="kr">(o)</span><span class="w"></span>
<span class="w">  </span><span class="kt">DataArray_t</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">ElementSize</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ParentElementsPosition</span><span class="p">;</span><span class="w">      </span><span class="kr">(o)</span><span class="w"></span>

<span class="w">  </span><span class="k">List</span><span class="p">(</span><span class="w"> </span><span class="kt">UserDefinedData_t</span><span class="w"> </span><span class="n">UserDefinedData1</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">UserDefinedDataN</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w">  </span><span class="kr">(o)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ol class="arabic simple">
<li><p>Default names for the <code class="code sidsref docutils literal notranslate"><span class="pre">Descriptor_t</span></code> and <code class="code sidsref docutils literal notranslate"><span class="pre">UserDefinedData_t</span></code> lists are as shown; users may choose other legitimate names. Legitimate names must be unique within a given instance of <code class="code sidskey docutils literal notranslate"><span class="pre">Elements_t</span></code> and shall not include the names <code class="code sidskey docutils literal notranslate"><span class="pre">ElementConnectivity</span></code>, <code class="code sidskey docutils literal notranslate"><span class="pre">ElementRange</span></code>, <code class="code sidskey docutils literal notranslate"><span class="pre">ParentElements</span></code>, <code class="code sidskey docutils literal notranslate"><span class="pre">ParentElementsPosition</span></code>, or <code class="code sidskey docutils literal notranslate"><span class="pre">Rind</span></code>.</p></li>
<li><p><code class="code sidsref docutils literal notranslate"><span class="pre">IndexRange_t</span></code>, <code class="code sidsref docutils literal notranslate"><span class="pre">ElementType_t</span></code>, and <code class="code sidsref docutils literal notranslate"><span class="pre">ElementConnectivity</span></code> are the required fields within the <code class="code sidskey docutils literal notranslate"><span class="pre">Elements_t</span></code> structure. <code class="code sidskey docutils literal notranslate"><span class="pre">ElementStartOffset</span></code> is required only for <code class="code sidskey docutils literal notranslate"><span class="pre">MIXED</span></code>, <code class="code sidskey docutils literal notranslate"><span class="pre">NGON_n</span></code> and <code class="code sidskey docutils literal notranslate"><span class="pre">NFACE_n</span></code> element type. <code class="code sidskey docutils literal notranslate"><span class="pre">Rind</span></code> has a default if absent; the default is equivalent to having a <code class="code sidskey docutils literal notranslate"><span class="pre">Rind</span></code> structure whose <code class="code sidskey docutils literal notranslate"><span class="pre">RindPlanes</span></code> array contains all zeros.</p></li>
</ol>
</div>
<p><code class="code sidsref docutils literal notranslate"><span class="pre">Rind</span></code> is an optional field that indicates the number of rind elements included in the elements data. If <code class="code sidskey docutils literal notranslate"><span class="pre">Rind</span></code> is absent, then the <code class="code sidsref docutils literal notranslate"><span class="pre">DataArray_t</span></code> structure entities contain only core elements of a zone. If <code class="code sidskey docutils literal notranslate"><span class="pre">Rind</span></code> is present, it will provide information on the number of rind elements, in addition to the core elements, that are contained in the <code class="code sidskey docutils literal notranslate"><span class="pre">DataArray_t</span></code> structures.</p>
<p>Note that the usage of rind data with respect to the size of the <code class="code sidskey docutils literal notranslate"><span class="pre">DataArray_t</span></code> structures is different under <code class="code sidskey docutils literal notranslate"><span class="pre">Elements_t</span></code> than elsewhere. For example, when rind coordinate data is stored under <code class="code sidsref docutils literal notranslate"><span class="pre">GridCoordinates_t</span></code>, the parameter <code class="code sidskey docutils literal notranslate"><span class="pre">VertexSize</span></code> accounts for the core data only. The size of the <code class="code sidskey docutils literal notranslate"><span class="pre">DataArray_t</span></code> structures containing the grid coordinates is determined by the <code class="code sidskey docutils literal notranslate"><span class="pre">DataSize</span></code> function, which adds the number of rind planes or points to <code class="code sidskey docutils literal notranslate"><span class="pre">VertexSize</span></code>. But for the element connectivity, the size of the <code class="code sidskey docutils literal notranslate"><span class="pre">DataArray_t</span></code> structures containing the connectivity data is just <code class="code sidskey docutils literal notranslate"><span class="pre">ElementDataSize</span></code>, which depends on <code class="code sidskey docutils literal notranslate"><span class="pre">ElementSize</span></code>, and includes both the core and rind elements.</p>
<p><code class="code sidskey docutils literal notranslate"><span class="pre">ElementRange</span></code> contains the index of the first and last elements defined in <code class="code sidsref docutils literal notranslate"><span class="pre">ElementConnectivity</span></code>. The elements are indexed with a global numbering system, starting at 1, for all element sections under a given <code class="code sidsref docutils literal notranslate"><span class="pre">Zone_t</span></code> data structure. The global numbering insures that each element, whether it’s a cell, a face, or an edge, is uniquely identified by its number. They are also listed as a continuous list of element numbers within any single element section. Therefore the number of elements in a section is:</p>
<pre class="literal-block">ElementSize = ElementRange.end - ElementRange.start + 1</pre>
<p>The element indices are used for the boundary condition and zone connectivity definition.</p>
<p><code class="code sidskey docutils literal notranslate"><span class="pre">ElementSizeBoundary</span></code> indicates if the elements are sorted, and how many boundary elements are recorded. By default, <code class="code sidskey docutils literal notranslate"><span class="pre">ElementSizeBoundary</span></code> is set to zero, indicating that the elements are not sorted. If the elements are sorted, <code class="code sidskey docutils literal notranslate"><span class="pre">ElementSizeBoundary</span></code> is set to the number of elements at the boundary. Consequently:</p>
<pre class="literal-block">ElementSizeInterior = ElementSize - ElementSizeBoundary</pre>
<p><code class="code sidskey docutils literal notranslate"><span class="pre">ElementType_t</span></code> is an enumeration of the supported element types:</p>
<div class="highlight-sids notranslate"><div class="highlight"><pre><span></span><span class="kt">ElementType_t</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">Enumeration</span><span class="p">(</span><span class="w"></span>
<span class="w">   </span><span class="n">ElementTypeNull</span><span class="p">,</span><span class="w"> </span><span class="n">ElementTypeUserDefined</span><span class="p">,</span><span class="w"> </span><span class="n">NODE</span><span class="p">,</span><span class="w"> </span><span class="n">BAR_2</span><span class="p">,</span><span class="w"> </span><span class="n">BAR_3</span><span class="p">,</span><span class="w"></span>
<span class="w">   </span><span class="n">TRI_3</span><span class="p">,</span><span class="w"> </span><span class="n">TRI_6</span><span class="p">,</span><span class="w"> </span><span class="n">QUAD_4</span><span class="p">,</span><span class="w"> </span><span class="n">QUAD_8</span><span class="p">,</span><span class="w"> </span><span class="n">QUAD_9</span><span class="p">,</span><span class="w"></span>
<span class="w">   </span><span class="n">TETRA_4</span><span class="p">,</span><span class="w"> </span><span class="n">TETRA_10</span><span class="p">,</span><span class="w"> </span><span class="n">PYRA_5</span><span class="p">,</span><span class="w"> </span><span class="n">PYRA_14</span><span class="p">,</span><span class="w"></span>
<span class="w">   </span><span class="n">PENTA_6</span><span class="p">,</span><span class="w"> </span><span class="n">PENTA_15</span><span class="p">,</span><span class="w"> </span><span class="n">PENTA_18</span><span class="p">,</span><span class="w"> </span><span class="n">HEXA_8</span><span class="p">,</span><span class="w"> </span><span class="n">HEXA_20</span><span class="p">,</span><span class="w"> </span><span class="n">HEXA_27</span><span class="p">,</span><span class="w"></span>
<span class="w">   </span><span class="n">MIXED</span><span class="p">,</span><span class="w"> </span><span class="n">PYRA_13</span><span class="p">,</span><span class="w"> </span><span class="n">NGON_n</span><span class="p">,</span><span class="w"> </span><span class="n">NFACE_n</span><span class="p">,</span><span class="w"></span>
<span class="w">   </span><span class="n">BAR_4</span><span class="p">,</span><span class="w"> </span><span class="n">TRI_9</span><span class="p">,</span><span class="w"> </span><span class="n">TRI_10</span><span class="p">,</span><span class="w"> </span><span class="n">QUAD_12</span><span class="p">,</span><span class="w"> </span><span class="n">QUAD_16</span><span class="p">,</span><span class="w"></span>
<span class="w">   </span><span class="n">TETRA_16</span><span class="p">,</span><span class="w"> </span><span class="n">TETRA_20</span><span class="p">,</span><span class="w"> </span><span class="n">PYRA_21</span><span class="p">,</span><span class="w"> </span><span class="n">PYRA_29</span><span class="p">,</span><span class="w"> </span><span class="n">PYRA_30</span><span class="p">,</span><span class="w"></span>
<span class="w">   </span><span class="n">PENTA_24</span><span class="p">,</span><span class="w"> </span><span class="n">PENTA_38</span><span class="p">,</span><span class="w"> </span><span class="n">PENTA_40</span><span class="p">,</span><span class="w"> </span><span class="n">HEXA_32</span><span class="p">,</span><span class="w"> </span><span class="n">HEXA_56</span><span class="p">,</span><span class="w"> </span><span class="n">HEXA_64</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The conventions for element numbering for the various supported types are described in <a class="reference internal" href="convention.html#unstructgrid"><span class="std std-ref">Unstructured Grid Element Numbering Conventions</span></a>.</p>
<p>For all element types except <code class="code sidskey docutils literal notranslate"><span class="pre">MIXED</span></code>, <code class="code sidskey docutils literal notranslate"><span class="pre">ElementConnectivity</span></code> contains the list of nodes for each element. If the elements are sorted, then it must first list the connectivity of the boundary elements, then that of the interior elements.</p>
<pre class="literal-block">ElementConnectivity = Node1<sub>1</sub>, Node2<sub>1</sub>, ... NodeN<sub>1</sub>,
                      Node1<sub>2</sub>, Node2<sub>2</sub>, ... NodeN<sub>2</sub>,
                      ...
                      Node1<sub>M</sub>, Node2<sub>M</sub>, ... NodeN<sub>M</sub></pre>
<p>where <code class="docutils literal notranslate"><span class="pre">M</span></code> is the total number of elements (i.e. <code class="code sidskey docutils literal notranslate"><span class="pre">ElementSize</span></code> ), and <code class="docutils literal notranslate"><span class="pre">N</span></code> is the number of nodes per element.</p>
<p><code class="code sidskey docutils literal notranslate"><span class="pre">ElementDataSize</span></code> indicates the total size (number of integers) of the array <code class="code sidskey docutils literal notranslate"><span class="pre">ElementConnectivity</span></code>. For all element types except <code class="code sidskey docutils literal notranslate"><span class="pre">MIXED</span></code>, <code class="code sidskey docutils literal notranslate"><span class="pre">NGON_n</span></code>, and <code class="code sidskey docutils literal notranslate"><span class="pre">NFACE_n</span></code>, <code class="code sidskey docutils literal notranslate"><span class="pre">ElementDataSize</span></code> is given by:</p>
<pre class="literal-block">ElementDataSize = ElementSize * NPE[ElementType]</pre>
<p>where <code class="code sidskey docutils literal notranslate"><span class="pre">NPE[ElementType]</span></code> is a function returning the number of nodes for the given <code class="code sidskey docutils literal notranslate"><span class="pre">ElementType</span></code>. For example, <code class="code sidskey docutils literal notranslate"><span class="pre">NPE[HEXA_8]=8</span></code>.</p>
<p>When the section <code class="code sidskey docutils literal notranslate"><span class="pre">ElementType</span></code> is <code class="code sidskey docutils literal notranslate"><span class="pre">MIXED</span></code>, the data array <code class="code sidskey docutils literal notranslate"><span class="pre">ElementConnectivity</span></code> contains
one extra integer per element, to hold each individual element type:</p>
<pre class="literal-block">ElementConnectivity = Etype<sub>1</sub>, Node1<sub>1</sub>, Node2<sub>1</sub>, ... NodeN<sub>1</sub>,
                      Etype<sub>2</sub>, Node1<sub>2</sub>, Node2<sub>2</sub>, ... NodeN<sub>2</sub>,
                      ...
                      Etype<sub>M</sub>, Node1<sub>M</sub>, Node2<sub>M</sub>, ... NodeN<sub>M</sub></pre>
<p>where again <code class="docutils literal notranslate"><span class="pre">M</span></code> is the total number of elements, and <span class="math notranslate nohighlight">\(\scriptsize\mathsf{N}_\mathrm{i}\)</span> <code class="docutils literal notranslate"><span class="pre">Ni</span></code>  is the number of nodes in element <code class="docutils literal notranslate"><span class="pre">i</span></code>.
The data array <code class="code sidskey docutils literal notranslate"><span class="pre">ElementStartOffset</span></code> contains the starting positions of each element in the <code class="code sidskey docutils literal notranslate"><span class="pre">ElementConnectivity</span></code> data array
and its last value corresponds to the <code class="code sidskey docutils literal notranslate"><span class="pre">ElementConnectivity</span></code> total size:</p>
<pre class="literal-block">ElementStartOffset  = 0, NPE[Etype<sub>1</sub>] + 1, ... ElementStartOffset[n-1] + NPE[Etype<sub>n</sub>] + 1,
                      ..., ElementStartOffset[M-1] + NPE[Etype<sub>M</sub>] + 1 = ElementDataSize</pre>
<p>In the case of <code class="code sidskey docutils literal notranslate"><span class="pre">MIXED</span></code> element section, <code class="code sidskey docutils literal notranslate"><span class="pre">ElementDataSize</span></code> is given by:</p>
<pre class="literal-block">ElementDataSize = ∑(NPE[ElementType<sub>n</sub>] + 1)</pre>
<p>where the summation is over <code class="docutils literal notranslate"><span class="pre">n</span></code>, and <code class="docutils literal notranslate"><span class="pre">n</span></code> represents a specific element type.</p>
<p>Arbitrary polyhedral elements may be defined using the <code class="code sidskey docutils literal notranslate"><span class="pre">NGON_n</span></code> and <code class="code sidskey docutils literal notranslate"><span class="pre">NFACE_n</span></code> element types. The <code class="code sidskey docutils literal notranslate"><span class="pre">NGON_n</span></code> element type is used to specify all the faces in the grid, and the <code class="code sidskey docutils literal notranslate"><span class="pre">NFACE_n</span></code> element type is then used to define the polyhedral elements as a collection of these faces. Except for boundary faces, each face of a polyhedral element must be shared by another polyhedral element.</p>
<p>For example, for <code class="code sidskey docutils literal notranslate"><span class="pre">NGON_n</span></code>, the data array <code class="code sidskey docutils literal notranslate"><span class="pre">ElementConnectivity</span></code> contains a list of nodes making up each face in the grid while <code class="code sidskey docutils literal notranslate"><span class="pre">ElementStartOffset</span></code> provides the starting position of each face in the <code class="code sidskey docutils literal notranslate"><span class="pre">ElementConnectivity</span></code> array:</p>
<pre class="literal-block">ElementConnectivity = Node1<sub>1</sub>, Node2<sub>1</sub>, ... NodeN<sub>1</sub>,
                      Node1<sub>2</sub>, Node2<sub>2</sub>, ... NodeN<sub>2</sub>,
                      ...
                      Node1<sub>M</sub>, Node2<sub>M</sub>, ... NodeN<sub>M</sub>

ElementStartOffset  = 0, Nnodes<sub>1</sub>, Nnodes<sub>1</sub> + Nnodes<sub>2</sub>, ...
                      ..., ElementStartOffset[i-1] + Nnodes<sub>i</sub>,
                      ..., ElementStartOffset[M-1] + Nnodes<sub>M</sub> = ElementDataSize</pre>
<p>where here <code class="docutils literal notranslate"><span class="pre">M</span></code> is the total number of faces, and <code class="docutils literal notranslate"><span class="pre">Nnodesi</span></code> is the number of nodes in face <code class="docutils literal notranslate"><span class="pre">i</span></code>.
The <code class="code sidskey docutils literal notranslate"><span class="pre">ElementDataSize</span></code> is the total number of nodes defining all the faces.
Note that the number of nodes in face <code class="docutils literal notranslate"><span class="pre">i</span></code> is given by:</p>
<pre class="literal-block">Nnodes<sub>i</sub> = ElementStartOffset[i+1] - ElementStartOffset[i]</pre>
<p>Then for <code class="code sidskey docutils literal notranslate"><span class="pre">NFACE_n</span></code>, <code class="code sidskey docutils literal notranslate"><span class="pre">ElementConnectivity</span></code> contains the list of face elements making up each polyhedral element,
while <code class="code sidskey docutils literal notranslate"><span class="pre">ElementStartOffset</span></code> provides the starting position of each polyhedral element in the <code class="code sidskey docutils literal notranslate"><span class="pre">ElementConnectivity</span></code> array:</p>
<pre class="literal-block">ElementConnectivity = Face1<sub>1</sub>, Face2<sub>1</sub>, ... FaceN<sub>1</sub>,
                      Face1<sub>2</sub>, Face2<sub>2</sub>, ... FaceN<sub>2</sub>,
                      ...
                      Face1<sub>M</sub>, Face2<sub>M</sub>, ... FaceN<sub>M</sub>

ElementStartOffset  = 0, Nfaces<sub>1</sub>, Nfaces<sub>1</sub> + Nfaces<sub>2</sub>, ...
                      ..., ElementStartOffset[i-1] + Nfaces<sub>i</sub>,
                      ..., ElementStartOffset[M-1] + Nfaces<sub>M</sub> = ElementDataSize</pre>
<p>where now <code class="docutils literal notranslate"><span class="pre">M</span></code> is the total number of polyhedral elements, and <code class="docutils literal notranslate"><span class="pre">Nfacesi</span></code> is the number of faces in element <code class="docutils literal notranslate"><span class="pre">i</span></code>.
The sign of the face number determines its orientation (i.e., the direction of the face normal, constructed as defined by the convention for 2-D elements). If the face number is positive, the face normal is directed outward; if it’s negative, the face normal is directed inward. The ElementDataSize is the sum of the number of faces defining each polyhedral element.
Note that the number of faces in element <code class="docutils literal notranslate"><span class="pre">i</span></code> is given by:</p>
<pre class="literal-block">Nfaces<sub>i</sub> = ElementStartOffset[i+1] - ElementStartOffset[i]</pre>
<p>For face elements in 3-D, or bar element in 2-D, additional data may be provided for each element in <code class="code sidskey docutils literal notranslate"><span class="pre">ParentElements</span></code> and <code class="code sidskey docutils literal notranslate"><span class="pre">ParentElementsPosition</span></code>.
The element numbers of the two adjacent cells for each face are given in <code class="code sidskey docutils literal notranslate"><span class="pre">ParentElements</span></code>.
The corresponding canonical positions of the face in the two parent cells is given in <code class="code sidskey docutils literal notranslate"><span class="pre">ParentElementsPosition</span></code>;
these canonical face positions are defined in the section <a class="reference internal" href="convention.html#unstructgrid"><span class="std std-ref">Unstructured Grid Element Numbering Conventions</span></a>.
For faces on the boundary of the domain, the second parent is set to zero.</p>
<p>The <code class="code sidskey docutils literal notranslate"><span class="pre">UserDefinedData_t</span></code> data structure allows arbitrary user-defined data to be stored in <code class="code sidskey docutils literal notranslate"><span class="pre">Descriptor_t</span></code> and
<code class="code sidskey docutils literal notranslate"><span class="pre">DataArray_t</span></code> children without the restrictions or implicit meanings imposed on these node types at other node locations.</p>
</section>
<section id="elements-examples">
<h2><span class="section-number">7.4. </span>Elements Examples<a class="headerlink" href="#elements-examples" title="Permalink to this headline">¶</a></h2>
<p>This section contains four examples of elements definition in CGNS.
The first example is for a simple three-element tetrahedral grid, using the <code class="code sidskey docutils literal notranslate"><span class="pre">TETRA_4</span></code> element type.
The second example is for the same grid as the first example, but the elements are treated as general polyhedra to illustrate the use of the <code class="code sidskey docutils literal notranslate"><span class="pre">NGON_n</span></code> and <code class="code sidskey docutils literal notranslate"><span class="pre">NFACE_n</span></code> element types.
The third and fourth examples are for an unstructured zone with 15 tetrahedral and 10 hexahedral elements, with the third example defining the elements in separate sections for the <code class="code sidskey docutils literal notranslate"><span class="pre">TETRA_4</span></code> and <code class="code sidskey docutils literal notranslate"><span class="pre">HEXA_8</span></code> element types, and the fourth example combining them using the <code class="code sidskey docutils literal notranslate"><span class="pre">MIXED</span></code> element type.</p>
<section id="example-tetra-4-element-types">
<h3><span class="section-number">7.4.1. </span>Example - TETRA_4 Element Types<a class="headerlink" href="#example-tetra-4-element-types" title="Permalink to this headline">¶</a></h3>
<p>This example uses the simple three-element tetrahedral grid shown below.</p>
<figure class="align-center" id="id1">
<a class="reference internal image-reference" href="../images/sids/figs/ex_tetra.gif"><img alt="Unstructured grid consisting of three tetrahedra" src="../images/sids/figs/ex_tetra.gif" style="width: 400px;" /></a>
<figcaption>
<p><span class="caption-text"><em>Example Tetrahedral Grid</em></span><a class="headerlink" href="#id1" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>The element type is <code class="code sidskey docutils literal notranslate"><span class="pre">TETRA_4</span></code>, and the connectivity is defined in <code class="code sidskey docutils literal notranslate"><span class="pre">ElementConnectivity</span></code> by specifying the four nodes comprising each element, with the order consistent with the <a class="reference internal" href="convention.html#unst-tetra"><span class="std std-ref">numbering conventions for tetrahedral elements</span></a>. The data in <code class="code sidskey docutils literal notranslate"><span class="pre">ElementConnectivity</span></code> is grouped by element; note that the parentheses are added here for presentation purposes only.</p>
<div class="highlight-sids notranslate"><div class="highlight"><pre><span></span><span class="kt">Zone_t</span><span class="w"> </span><span class="n">UnstructuredZone</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">  </span><span class="p">{{</span><span class="w"></span>
<span class="w">  </span><span class="kt">Elements_t</span><span class="w"> </span><span class="n">TetraElements</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="p">{{</span><span class="w"></span>
<span class="w">    </span><span class="kt">IndexRange_t</span><span class="w"> </span><span class="n">ElementRange</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kt">ElementType_t</span><span class="w"> </span><span class="n">ElementType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TETRA_4</span><span class="w"> </span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kt">DataArray_t</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">NPE</span><span class="p">[</span><span class="n">TETRA_4</span><span class="p">]</span><span class="w"> </span><span class="o">×</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ElementConnectivity</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">      </span><span class="p">{{</span><span class="w"></span>
<span class="w">      </span><span class="k">Data</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">NPE</span><span class="p">[</span><span class="n">TETRA_4</span><span class="p">]</span><span class="w"> </span><span class="o">×</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">        </span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="example-ngon-n-and-nface-n-element-types">
<h3><span class="section-number">7.4.2. </span>Example - NGON_n and NFACE_n Element Types<a class="headerlink" href="#example-ngon-n-and-nface-n-element-types" title="Permalink to this headline">¶</a></h3>
<p>This example uses the same grid as in the previous example, but treats the elements as general polyhedra to illustrate the use of the <code class="code sidskey docutils literal notranslate"><span class="pre">NGON_n</span></code> and <code class="code sidskey docutils literal notranslate"><span class="pre">NFACE_n</span></code> element types. The grid consists of three volume elements, each made up of four face elements, with each face defined by three nodes.</p>
<p>For each face, the nodes comprising that face are listed in <code class="code sidskey docutils literal notranslate"><span class="pre">ElementConnectivity</span></code> for the <code class="code sidskey docutils literal notranslate"><span class="pre">NGON_n</span></code> element type.
The <code class="code sidskey docutils literal notranslate"><span class="pre">ElementRange</span></code> is <code class="docutils literal notranslate"><span class="pre">[1,10]</span></code>, corresponding to the 10 total faces in the grid. The <code class="code sidskey docutils literal notranslate"><span class="pre">ElementDataSize</span></code> is 30, corresponding to the total of 30 nodes defining the 10 faces.</p>
<p>The faces making up the three volume elements are then listed in <code class="code sidskey docutils literal notranslate"><span class="pre">ElementConnectivity</span></code> for the <code class="code sidskey docutils literal notranslate"><span class="pre">NFACE_n</span></code> element type. The <code class="code sidskey docutils literal notranslate"><span class="pre">ElementRange</span></code> is <code class="docutils literal notranslate"><span class="pre">[11,13]</span></code>, corresponding to the three volume elements. The <code class="code sidskey docutils literal notranslate"><span class="pre">ElementDataSize</span></code> is 12, corresponding to three volume elements with four faces per element. Note that the face numbers for faces 3 and 8 are negative in the definition of volume element 3, since their normals point inward for that element. Again, the parentheses in <code class="code sidskey docutils literal notranslate"><span class="pre">ElementConnectivity</span></code> are for presentation purposes only.</p>
<div class="highlight-sids notranslate"><div class="highlight"><pre><span></span><span class="kt">Zone_t</span><span class="w"> </span><span class="n">UnstructuredZone</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">  </span><span class="p">{{</span><span class="w"></span>
<span class="w">  </span><span class="kt">Elements_t</span><span class="w"> </span><span class="n">NgonElements</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="p">{{</span><span class="w"></span>
<span class="w">    </span><span class="kt">IndexRange_t</span><span class="w"> </span><span class="n">ElementRange</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span><span class="w"> </span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kt">ElementType_t</span><span class="w"> </span><span class="n">ElementType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NGON_n</span><span class="w"> </span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kt">DataArray_t</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">30</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ElementConnectivity</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">      </span><span class="p">{{</span><span class="w"></span>
<span class="w">      </span><span class="k">Data</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">30</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">        </span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">),</span><span class="w"></span>
<span class="w">        </span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">),</span><span class="w"></span>
<span class="w">        </span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">DataArray_t</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">11</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ElementStartOffset</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">      </span><span class="p">{{</span><span class="w"></span>
<span class="w">      </span><span class="k">Data</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">11</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">         </span><span class="mi">0</span><span class="p">,</span><span class="w">  </span><span class="mi">3</span><span class="p">,</span><span class="w">  </span><span class="mi">6</span><span class="p">,</span><span class="w">  </span><span class="mi">9</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="mi">12</span><span class="p">,</span><span class="w"> </span><span class="mi">15</span><span class="p">,</span><span class="w"> </span><span class="mi">18</span><span class="p">,</span><span class="w"> </span><span class="mi">21</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="mi">24</span><span class="p">,</span><span class="w"> </span><span class="mi">27</span><span class="p">,</span><span class="w"> </span><span class="mi">30</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">Elements_t</span><span class="w"> </span><span class="n">NfaceElements</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="p">{{</span><span class="w"></span>
<span class="w">    </span><span class="kt">IndexRange_t</span><span class="w"> </span><span class="n">ElementRange</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">11</span><span class="p">,</span><span class="mi">13</span><span class="p">]</span><span class="w"> </span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kt">ElementType_t</span><span class="w"> </span><span class="n">ElementType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NFACE_n</span><span class="w"> </span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kt">DataArray_t</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">12</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ElementConnectivity</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">      </span><span class="p">{{</span><span class="w"></span>
<span class="w">      </span><span class="k">Data</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">12</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">        </span><span class="p">(</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">  </span><span class="mi">2</span><span class="p">,</span><span class="w">  </span><span class="mi">3</span><span class="p">,</span><span class="w">  </span><span class="mi">4</span><span class="p">),</span><span class="w"></span>
<span class="w">        </span><span class="p">(</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w">  </span><span class="mi">6</span><span class="p">,</span><span class="w">  </span><span class="mi">7</span><span class="p">,</span><span class="w">  </span><span class="mi">8</span><span class="p">),</span><span class="w"></span>
<span class="w">        </span><span class="p">(</span><span class="mi">-8</span><span class="p">,</span><span class="w">  </span><span class="mi">9</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">-3</span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">DataArray_t</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ElementStartOffset</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">      </span><span class="p">{{</span><span class="w"></span>
<span class="w">      </span><span class="k">Data</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">         </span><span class="mi">0</span><span class="p">,</span><span class="w">  </span><span class="mi">4</span><span class="p">,</span><span class="w">  </span><span class="mi">8</span><span class="p">,</span><span class="w">  </span><span class="mi">12</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="example-separate-element-types">
<h3><span class="section-number">7.4.3. </span>Example - Separate Element Types<a class="headerlink" href="#example-separate-element-types" title="Permalink to this headline">¶</a></h3>
<p>In this example, elements are defined for an unstructured zone with 15 tetrahedral and 10 hexahedral elements. The elements are written in two separate sections, one for the tetrahedral elements and one for the hexahedral elements.</p>
<div class="highlight-sids notranslate"><div class="highlight"><pre><span></span><span class="kt">Zone_t</span><span class="w"> </span><span class="n">UnstructuredZone</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">  </span><span class="p">{{</span><span class="w"></span>
<span class="w">  </span><span class="kt">Elements_t</span><span class="w"> </span><span class="n">TetraElements</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="p">{{</span><span class="w"></span>
<span class="w">    </span><span class="kt">IndexRange_t</span><span class="w"> </span><span class="n">ElementRange</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">15</span><span class="p">]</span><span class="w"> </span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">ElementSizeBoundary</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kt">ElementType_t</span><span class="w"> </span><span class="n">ElementType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TETRA_4</span><span class="w"> </span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kt">DataArray_t</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">NPE</span><span class="p">[</span><span class="n">TETRA_4</span><span class="p">]</span><span class="w"> </span><span class="o">×</span><span class="w"> </span><span class="mi">15</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ElementConnectivity</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">      </span><span class="p">{{</span><span class="w"></span>
<span class="w">      </span><span class="k">Data</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">NPE</span><span class="p">[</span><span class="n">TETRA_4</span><span class="p">]</span><span class="w"> </span><span class="o">×</span><span class="w"> </span><span class="mi">15</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">node</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">),</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">NPE</span><span class="p">[</span><span class="n">TETRA_4</span><span class="p">],</span><span class="w"> </span><span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="mi">15</span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">Elements_t</span><span class="w"> </span><span class="n">HexaElements</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="p">{{</span><span class="w"></span>
<span class="w">    </span><span class="kt">IndexRange_t</span><span class="w"> </span><span class="n">ElementRange</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">16</span><span class="p">,</span><span class="mi">25</span><span class="p">]</span><span class="w"> </span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">ElementSizeBoundary</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kt">ElementType_t</span><span class="w"> </span><span class="n">ElementType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">HEXA_8</span><span class="w"> </span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kt">DataArray_t</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">NPE</span><span class="p">[</span><span class="n">HEXA_8</span><span class="p">]</span><span class="w"> </span><span class="o">×</span><span class="w"> </span><span class="mi">10</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ElementConnectivity</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">      </span><span class="p">{{</span><span class="w"></span>
<span class="w">      </span><span class="k">Data</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">NPE</span><span class="p">[</span><span class="n">HEXA_8</span><span class="p">]</span><span class="w"> </span><span class="o">×</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">node</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">),</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">NPE</span><span class="p">[</span><span class="n">HEXA_8</span><span class="p">],</span><span class="w"> </span><span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="example-mixed-element-type">
<h3><span class="section-number">7.4.4. </span>Example - MIXED Element Type<a class="headerlink" href="#example-mixed-element-type" title="Permalink to this headline">¶</a></h3>
<p>In this example, the same unstructured zone described in the previous example is written in a single element section of type <code class="code sidskey docutils literal notranslate"><span class="pre">MIXED</span></code> (i.e., an unstructured grid composed of mixed elements).</p>
<div class="highlight-sids notranslate"><div class="highlight"><pre><span></span><span class="kt">Zone_t</span><span class="w"> </span><span class="n">UnstructuredZone</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">  </span><span class="p">{{</span><span class="w"></span>
<span class="w">  </span><span class="kt">Elements_t</span><span class="w"> </span><span class="n">MixedElementsSection</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="p">{{</span><span class="w"></span>
<span class="w">    </span><span class="kt">IndexRange_t</span><span class="w"> </span><span class="n">ElementRange</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">25</span><span class="p">]</span><span class="w"> </span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kt">ElementType_t</span><span class="w"> </span><span class="n">ElementType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MIXED</span><span class="w"> </span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kt">DataArray_t</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">ElementDataSize</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ElementConnectivity</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">      </span><span class="p">{{</span><span class="w"></span>
<span class="w">      </span><span class="k">Data</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">ElementDataSize</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">etype</span><span class="p">(</span><span class="n">j</span><span class="p">),(</span><span class="n">node</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">),</span><span class="w"></span>
<span class="w">           </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">NPE</span><span class="p">[</span><span class="n">etype</span><span class="p">(</span><span class="n">j</span><span class="p">)]),</span><span class="w"> </span><span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="mi">25</span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">DataArray_t</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">26</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ElementStartOffset</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">      </span><span class="p">{{</span><span class="w"></span>
<span class="w">      </span><span class="k">Data</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">26</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">         </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">NPE</span><span class="p">[</span><span class="n">etype</span><span class="p">(</span><span class="n">j</span><span class="p">)]</span><span class="o">+</span><span class="n">ElementStartOffset</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="mi">25</span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="axisymmetry-structure-definition-axisymmetry-t">
<h2><span class="section-number">7.5. </span>Axisymmetry Structure Definition: <code class="docutils literal notranslate"><span class="pre">Axisymmetry_t</span></code><a class="headerlink" href="#axisymmetry-structure-definition-axisymmetry-t" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>The <code class="code sidskey docutils literal notranslate"><span class="pre">Axisymmetry_t</span></code> data structure allows recording the axis of rotation and the angle of rotation around this axis for a two-dimensional dataset that represents an axisymmetric database.</p>
</div></blockquote>
<div class="highlight-sids notranslate"><div class="highlight"><pre><span></span><span class="kt">Axisymmetry_t</span><span class="w"> </span><span class="o">:=</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">List</span><span class="p">(</span><span class="w"> </span><span class="kt">Descriptor_t</span><span class="w"> </span><span class="n">Descriptor1</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">DescriptorN</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w">                 </span><span class="kr">(o)</span><span class="w"></span>

<span class="w">  </span><span class="kt">DataArray_t</span><span class="o">&lt;</span><span class="kt">real</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">AxisymmetryReferencePoint</span><span class="w"> </span><span class="p">;</span><span class="w">                  </span><span class="kr">(r)</span><span class="w"></span>
<span class="w">  </span><span class="kt">DataArray_t</span><span class="o">&lt;</span><span class="kt">real</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">AxisymmetryAxisVector</span><span class="w"> </span><span class="p">;</span><span class="w">                      </span><span class="kr">(r)</span><span class="w"></span>
<span class="w">  </span><span class="kt">DataArray_t</span><span class="o">&lt;</span><span class="kt">real</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">AxisymmetryAngle</span><span class="w"> </span><span class="p">;</span><span class="w">                           </span><span class="kr">(o)</span><span class="w"></span>
<span class="w">  </span><span class="kt">DataArray_t</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="mi">2</span><span class="p">,[</span><span class="mi">32</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">&gt;</span><span class="w"> </span><span class="n">CoordinateNames</span><span class="w"> </span><span class="p">;</span><span class="w">                       </span><span class="kr">(o)</span><span class="w"></span>

<span class="w">  </span><span class="kt">DataClass_t</span><span class="w"> </span><span class="n">DataClass</span><span class="w"> </span><span class="p">;</span><span class="w">                                            </span><span class="kr">(o)</span><span class="w"></span>

<span class="w">  </span><span class="kt">DimensionalUnits_t</span><span class="w"> </span><span class="n">DimensionalUnits</span><span class="w"> </span><span class="p">;</span><span class="w">                              </span><span class="kr">(o)</span><span class="w"></span>

<span class="w">  </span><span class="k">List</span><span class="p">(</span><span class="w"> </span><span class="kt">UserDefinedData_t</span><span class="w"> </span><span class="n">UserDefinedData1</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">UserDefinedDataN</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w">  </span><span class="kr">(o)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ol class="arabic simple">
<li><p>Default names for the <code class="code sidsref docutils literal notranslate"><span class="pre">Descriptor_t</span></code> and <code class="code sidsref docutils literal notranslate"><span class="pre">UserDefinedData_t</span></code> lists are as shown; users may choose other legitimate names. Legitimate names must be unique within a given instance of Axisymmetry_t and shall not include the names AxisymmetryAngle, AxisymmetryAxisVector, AxisymmetryReferencePoint, CoordinateNames, DataClass, or DimensionalUnits.</p></li>
<li><p><code class="code sidskey docutils literal notranslate"><span class="pre">AxisymmetryReferencePoint</span></code> and <code class="code sidskey docutils literal notranslate"><span class="pre">AxisymmetryAxisVector</span></code> are the required fields within the <code class="code sidskey docutils literal notranslate"><span class="pre">Axisymmetry_t</span></code> structure.</p></li>
</ol>
</div>
<p><code class="code sidskey docutils literal notranslate"><span class="pre">AxisymmetryReferencePoint</span></code> specifies the origin used for defining the axis of rotation.</p>
<p><code class="code sidskey docutils literal notranslate"><span class="pre">AxisymmetryAxisVector</span></code> contains the direction cosines of the axis of rotation, through the <code class="code sidskey docutils literal notranslate"><span class="pre">AxisymmetryReferencePoint</span></code>. For example, for a 2-D dataset defined in the <span class="math notranslate nohighlight">\((x,y)\)</span> plane, if <code class="code sidskey docutils literal notranslate"><span class="pre">AxisymmetryReferencePoint</span></code> contains <span class="math notranslate nohighlight">\((0,0)\)</span> and <code class="code sidskey docutils literal notranslate"><span class="pre">AxisymmetryAxisVector</span></code> contains <span class="math notranslate nohighlight">\((1,0)\)</span>, the x-axis is the axis of rotation.</p>
<p><code class="code sidskey docutils literal notranslate"><span class="pre">AxisymmetryAngle</span></code> allows specification of the circumferential extent about the axis of rotation. If this angle is undefined, it is assumed to be 360°.</p>
<p><code class="code sidskey docutils literal notranslate"><span class="pre">CoordinateNames</span></code> may be used to specify the first and second coordinates used in the definition of <code class="code sidskey docutils literal notranslate"><span class="pre">AxisymmetryReferencePoint</span></code> and <code class="code sidskey docutils literal notranslate"><span class="pre">AxisymmetryAxisVector</span></code>. If not found, it is assumed that the first coordinate is <code class="code sidskey docutils literal notranslate"><span class="pre">CoordinateX</span></code> and the second is <code class="code sidskey docutils literal notranslate"><span class="pre">CoordinateY</span></code>. The coordinates given under <code class="code sidskey docutils literal notranslate"><span class="pre">CoordinateNames</span></code>, or implied by using the default, must correspond to those found under <code class="code sidsref docutils literal notranslate"><span class="pre">GridCoordinates_t</span></code>.</p>
<p><code class="code sidsref docutils literal notranslate"><span class="pre">DataClass</span></code> defines the default class for numerical data contained in the <code class="code sidsref docutils literal notranslate"><span class="pre">DataArray_t</span></code> entities. For dimensional data, <code class="code sidsref docutils literal notranslate"><span class="pre">DimensionalUnits</span></code> may be used to describe the system of units employed. If present, these two entities take precedence over the corresponding entities at higher levels of the CGNS hierarchy, following the standard <a class="reference internal" href="hierarchy.html#precedence"><span class="std std-ref">precedence rules</span></a>.</p>
<p>The <code class="code sidsref docutils literal notranslate"><span class="pre">UserDefinedData_t</span></code> data structure allows arbitrary user-defined data to be stored in <code class="code sidskey docutils literal notranslate"><span class="pre">Descriptor_t</span></code> and <code class="code sidskey docutils literal notranslate"><span class="pre">DataArray_t</span></code> children without the restrictions or implicit meanings imposed on these node types at other node locations.</p>
</section>
<section id="rotating-coordinates-structure-definition-rotatingcoordinates-t">
<h2><span class="section-number">7.6. </span>Rotating Coordinates Structure Definition: <code class="docutils literal notranslate"><span class="pre">RotatingCoordinates_t</span></code><a class="headerlink" href="#rotating-coordinates-structure-definition-rotatingcoordinates-t" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>The <code class="code sidskey docutils literal notranslate"><span class="pre">RotatingCoordinates_t</span></code> data structure is used to record the rotation center and rotation rate vector of a rotating coordinate system.</p>
</div></blockquote>
<div class="highlight-sids notranslate"><div class="highlight"><pre><span></span><span class="kt">RotatingCoordinates_t</span><span class="w"> </span><span class="o">:=</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">List</span><span class="p">(</span><span class="w"> </span><span class="kt">Descriptor_t</span><span class="w"> </span><span class="n">Descriptor1</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">DescriptorN</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w">                 </span><span class="kr">(o)</span><span class="w"></span>

<span class="w">  </span><span class="kt">DataArray_t</span><span class="o">&lt;</span><span class="kt">real</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">PhysicalDimension</span><span class="o">&gt;</span><span class="w"> </span><span class="n">RotationCenter</span><span class="w"> </span><span class="p">;</span><span class="w">             </span><span class="kr">(r)</span><span class="w"></span>
<span class="w">  </span><span class="kt">DataArray_t</span><span class="o">&lt;</span><span class="kt">real</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">PhysicalDimension</span><span class="o">&gt;</span><span class="w"> </span><span class="n">RotationRateVector</span><span class="w"> </span><span class="p">;</span><span class="w">         </span><span class="kr">(r)</span><span class="w"></span>

<span class="w">  </span><span class="kt">DataClass_t</span><span class="w"> </span><span class="n">DataClass</span><span class="w"> </span><span class="p">;</span><span class="w">                                            </span><span class="kr">(o)</span><span class="w"></span>

<span class="w">  </span><span class="kt">DimensionalUnits_t</span><span class="w"> </span><span class="n">DimensionalUnits</span><span class="w"> </span><span class="p">;</span><span class="w">                              </span><span class="kr">(o)</span><span class="w"></span>

<span class="w">  </span><span class="k">List</span><span class="p">(</span><span class="w"> </span><span class="kt">UserDefinedData_t</span><span class="w"> </span><span class="n">UserDefinedData1</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">UserDefinedDataN</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w">  </span><span class="kr">(o)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ol class="arabic simple">
<li><p>Default names for the <code class="code sidsref docutils literal notranslate"><span class="pre">Descriptor_t</span></code> and <code class="code sidsref docutils literal notranslate"><span class="pre">UserDefinedData_t</span></code> lists are as shown; users may choose other legitimate names. Legitimate names must be unique within a given instance of <code class="code sidskey docutils literal notranslate"><span class="pre">RotatingCoordinates_t</span></code> and shall not include the names <code class="code sidskey docutils literal notranslate"><span class="pre">DataClass</span></code>, <code class="code sidskey docutils literal notranslate"><span class="pre">DimensionalUnits</span></code>, <code class="code sidskey docutils literal notranslate"><span class="pre">RotationCenter</span></code>, or <code class="code sidskey docutils literal notranslate"><span class="pre">RotationRateVector</span></code>.</p></li>
<li><p><code class="code sidskey docutils literal notranslate"><span class="pre">RotationCenter</span></code> and <code class="code sidskey docutils literal notranslate"><span class="pre">RotationRateVector</span></code> are the required fields within the <code class="code sidskey docutils literal notranslate"><span class="pre">RotatingCoordinates_t</span></code> structure.</p></li>
</ol>
</div>
<p><code class="code sidskey docutils literal notranslate"><span class="pre">RotationCenter</span></code> specifies the coordinates of the center of rotation, and <code class="code sidskey docutils literal notranslate"><span class="pre">RotationRateVector</span></code> specifies the components of the angular velocity of the grid about the center of rotation. Together, they define the angular velocity vector. The direction of the angular velocity vector specifies the axis of rotation, and its magnitude specifies the rate of rotation.</p>
<p>For example, for the common situation of rotation about the x-axis, <code class="code sidskey docutils literal notranslate"><span class="pre">RotationCenter</span></code> would be specified as any point on the x-axis, like <span class="math notranslate nohighlight">\((0,0,0)\)</span>. <code class="code sidskey docutils literal notranslate"><span class="pre">RotationRateVector</span></code> would then be specified as <span class="math notranslate nohighlight">\((ω,0,0)\)</span>, where ω is the rotation rate. Using the right-hand rule, ω would be positive for clockwise rotation (looking in the +x direction), and negative for counter-clockwise rotation.</p>
<p>Note that for a rotating coordinate system, the axis of rotation is defined in the inertial frame of reference, while the grid coordinates stored using the <code class="code sidsref docutils literal notranslate"><span class="pre">GridCoordinates_t</span></code> data structure are relative to the rotating frame of reference.</p>
<p><code class="code sidsref docutils literal notranslate"><span class="pre">DataClass</span></code> defines the default class for data contained in the <code class="code sidsref docutils literal notranslate"><span class="pre">DataArray_t</span></code> entities. For dimensional data, <code class="code sidsref docutils literal notranslate"><span class="pre">DimensionalUnits</span></code> may be used to describe the system of units employed. If present, these two entities take precedence over the corresponding entities at higher levels of the CGNS hierarchy, following the standard <a class="reference internal" href="hierarchy.html#precedence"><span class="std std-ref">precedence rules</span></a>.</p>
<p>The <code class="code sidsref docutils literal notranslate"><span class="pre">UserDefinedData_t</span></code> data structure allows arbitrary user-defined data to be stored in <code class="code sidskey docutils literal notranslate"><span class="pre">Descriptor_t</span></code> and <code class="code sidskey docutils literal notranslate"><span class="pre">DataArray_t</span></code> children without the restrictions or implicit meanings imposed on these node types at other node locations.</p>
<p>If rotating coordinates are used, it is useful to store variables relative to the rotating frame. Standardized data-name identifiers should be used for these variables, as defined for flow-solution quantities in the section <a class="reference internal" href="appendix_a.html#dataname"><span class="std std-ref">Conventions for Data-Name Identifiers</span></a>.</p>
</section>
<section id="flow-solution-structure-definition-flowsolution-t">
<h2><span class="section-number">7.7. </span>Flow Solution Structure Definition: <code class="code sidskey docutils literal notranslate"><span class="pre">FlowSolution_t</span></code><a class="headerlink" href="#flow-solution-structure-definition-flowsolution-t" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>The flow solution within a given zone is described by the <code class="code sidskey docutils literal notranslate"><span class="pre">FlowSolution_t</span></code> structure. This structure contains a list for the data arrays of the individual flow-solution variables, as well as identifying the grid location of the solution. It also provides a mechanism for identifying rind-point data included within the data arrays.</p>
</div></blockquote>
<div class="highlight-sids notranslate"><div class="highlight"><pre><span></span><span class="kt">FlowSolution_t</span><span class="o">&lt;</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">CellDimension</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">IndexDimension</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="kt">int</span><span class="w"> </span><span class="n">VertexSize</span><span class="p">[</span><span class="n">IndexDimension</span><span class="p">],</span><span class="w"></span>
<span class="w">                </span><span class="kt">int</span><span class="w"> </span><span class="n">CellSize</span><span class="p">[</span><span class="n">IndexDimension</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="o">:=</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">List</span><span class="p">(</span><span class="w"> </span><span class="kt">Descriptor_t</span><span class="w"> </span><span class="n">Descriptor1</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">DescriptorN</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w">                 </span><span class="kr">(o)</span><span class="w"></span>

<span class="w">  </span><span class="kt">GridLocation_t</span><span class="w"> </span><span class="n">GridLocation</span><span class="w"> </span><span class="p">;</span><span class="w">                                      </span><span class="kr">(o/d)</span><span class="w"></span>

<span class="w">  </span><span class="kt">Rind_t</span><span class="o">&lt;</span><span class="n">IndexDimension</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Rind</span><span class="w"> </span><span class="p">;</span><span class="w">                                      </span><span class="kr">(o/d)</span><span class="w"></span>

<span class="w">  </span><span class="kt">IndexRange_t</span><span class="o">&lt;</span><span class="n">IndexDimension</span><span class="o">&gt;</span><span class="w"> </span><span class="n">PointRange</span><span class="w"> </span><span class="p">;</span><span class="w">                          </span><span class="kr">(o)</span><span class="w"></span>
<span class="w">  </span><span class="kt">IndexArray_t</span><span class="o">&lt;</span><span class="n">IndexDimension</span><span class="p">,</span><span class="w"> </span><span class="n">ListLength</span><span class="p">[],</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">PointList</span><span class="w"> </span><span class="p">;</span><span class="w">        </span><span class="kr">(o)</span><span class="w"></span>

<span class="w">  </span><span class="k">List</span><span class="p">(</span><span class="w"> </span><span class="kt">DataArray_t</span><span class="o">&lt;</span><span class="n">DataType</span><span class="p">,</span><span class="w"> </span><span class="n">IndexDimension</span><span class="p">,</span><span class="w"> </span><span class="n">DataSize</span><span class="p">[]</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">          </span><span class="n">DataArray1</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">DataArrayN</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w">                              </span><span class="kr">(o)</span><span class="w"></span>

<span class="w">  </span><span class="kt">DataClass_t</span><span class="w"> </span><span class="n">DataClass</span><span class="w"> </span><span class="p">;</span><span class="w">                                            </span><span class="kr">(o)</span><span class="w"></span>

<span class="w">  </span><span class="kt">DimensionalUnits_t</span><span class="w"> </span><span class="n">DimensionalUnits</span><span class="w"> </span><span class="p">;</span><span class="w">                              </span><span class="kr">(o)</span><span class="w"></span>

<span class="w">  </span><span class="k">List</span><span class="p">(</span><span class="w"> </span><span class="kt">UserDefinedData_t</span><span class="w"> </span><span class="n">UserDefinedData1</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">UserDefinedDataN</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w">  </span><span class="kr">(o)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ol class="arabic simple">
<li><p>Default names for the <code class="code sidsref docutils literal notranslate"><span class="pre">Descriptor_t</span></code>, <code class="code sidsref docutils literal notranslate"><span class="pre">DataArray_t</span></code>, and <code class="code sidsref docutils literal notranslate"><span class="pre">UserDefinedData_t</span></code> lists are as shown; users may choose other legitimate names. Legitimate names must be unique within a given instance of <code class="code sidskey docutils literal notranslate"><span class="pre">FlowSolution_t</span></code> and shall not include the names <code class="code sidskey docutils literal notranslate"><span class="pre">DataClass</span></code>, <code class="code sidskey docutils literal notranslate"><span class="pre">DimensionalUnits</span></code>, <code class="code sidskey docutils literal notranslate"><span class="pre">GridLocation</span></code>, <code class="code sidskey docutils literal notranslate"><span class="pre">PointList</span></code>, <code class="code sidskey docutils literal notranslate"><span class="pre">PointRange</span></code>, or <code class="code sidskey docutils literal notranslate"><span class="pre">Rind</span></code>.</p></li>
<li><p>There are no required fields for <code class="code sidskey docutils literal notranslate"><span class="pre">FlowSolution_t</span></code>. <code class="code sidsref docutils literal notranslate"><span class="pre">GridLocation</span></code> has a default of <code class="code sidskey docutils literal notranslate"><span class="pre">Vertex</span></code> if absent. <code class="code sidskey docutils literal notranslate"><span class="pre">Rind</span></code> also has a default if absent; the default is equivalent to having an instance of <code class="code sidskey docutils literal notranslate"><span class="pre">Rind</span></code> whose <code class="code sidskey docutils literal notranslate"><span class="pre">RindPlanes</span></code> array contains all zeros.</p></li>
<li><p>Both of the fields <code class="code sidskey docutils literal notranslate"><span class="pre">PointList</span></code> and <code class="code sidskey docutils literal notranslate"><span class="pre">PointRange</span></code> are optional. Only one of these two fields may be specified.</p></li>
<li><p>The structure parameter <code class="code sidskey docutils literal notranslate"><span class="pre">DataType</span></code> must be consistent with the data stored in the <code class="code sidsref docutils literal notranslate"><span class="pre">DataArray_t</span></code> structure entities; <code class="code sidskey docutils literal notranslate"><span class="pre">DataType</span></code> is <code class="code docutils literal notranslate"><span class="pre">real</span></code> for all flow-solution identifiers defined in the section <a class="reference internal" href="appendix_a.html#dataname"><span class="std std-ref">Conventions for Data-Name Identifiers</span></a>.</p></li>
<li><p>For unstructured zones <code class="code sidsref docutils literal notranslate"><span class="pre">GridLocation</span></code> options are limited to <code class="code sidskey docutils literal notranslate"><span class="pre">Vertex</span></code> or <code class="code sidskey docutils literal notranslate"><span class="pre">CellCenter</span></code>, unless one of <code class="code sidskey docutils literal notranslate"><span class="pre">PointList</span></code> or <code class="code sidskey docutils literal notranslate"><span class="pre">PointRange</span></code> is present.</p></li>
<li><p>Indexing of data within the <code class="code sidsref docutils literal notranslate"><span class="pre">DataArray_t</span></code> structure must ne consistent with the associated numbering of vertices or elements.</p></li>
</ol>
</div>
<p><code class="code sidskey docutils literal notranslate"><span class="pre">FlowSolution_t</span></code> requires four structure parameters; <code class="code sidskey docutils literal notranslate"><span class="pre">CellDimension</span></code> identifies the dimensionality of cells or elements, <code class="code sidskey docutils literal notranslate"><span class="pre">IndexDimension</span></code> identifies the dimensionality of the grid-size arrays, and <code class="code sidskey docutils literal notranslate"><span class="pre">VertexSize</span></code> and <code class="code sidskey docutils literal notranslate"><span class="pre">CellSize</span></code> are the number of core vertices and cells, respectively, in each index direction, excluding rind points. For structured zones, core vertices and cells begin at <code class="code docutils literal notranslate"><span class="pre">[1,1,1]</span></code> (in 3-D) and end at <code class="code sidskey docutils literal notranslate"><span class="pre">VertexSize</span></code> and <code class="code sidskey docutils literal notranslate"><span class="pre">CellSize</span></code>, respectively. For unstructured zones, <code class="code sidskey docutils literal notranslate"><span class="pre">IndexDimension</span></code> is always 1.</p>
<p>The flow solution data is stored in the list of <code class="code sidsref docutils literal notranslate"><span class="pre">DataArray_t</span></code> entities; each <code class="code sidskey docutils literal notranslate"><span class="pre">DataArray_t</span></code> structure entity may contain a single component of the solution vector. Standardized data-name identifiers for the flow-solution quantities are described in the section <a class="reference internal" href="appendix_a.html#dataname"><span class="std std-ref">Conventions for Data-Name Identifiers</span></a>. The field <code class="code sidsref docutils literal notranslate"><span class="pre">GridLocation</span></code> specifies the location of the solution data with respect to the grid; if absent, the data is assumed to coincide with grid vertices (i.e., <code class="code sidskey docutils literal notranslate"><span class="pre">GridLocation</span> <span class="pre">=</span> <span class="pre">Vertex</span></code>). All data within a given instance of <code class="code sidskey docutils literal notranslate"><span class="pre">FlowSolution_t</span></code> must reside at the same grid location.</p>
<p>For structured grids, the value of <code class="code sidskey docutils literal notranslate"><span class="pre">GridLocation</span></code> alone specifies the location and indexing of the flow solution data. Vertices are explicity indexed. Cell centers and face centers are indexed using the minimum of the connecting vertex indices, as described in the section <a class="reference internal" href="convention.html#structgrid"><span class="std std-ref">Structured Grid Notation and Indexing Conventions</span></a>.</p>
<p>For unstructured grids, the value of <code class="code sidskey docutils literal notranslate"><span class="pre">GridLocation</span></code> alone specifies location and indexing of flow solution data only for vertex and cell-centered data. The reason for this is that element-based grid connectivity provided in the <code class="code sidsref docutils literal notranslate"><span class="pre">Elements_t</span></code> data structures explicitly indexes only vertices and cells. For data stored at alternate grid locations (e.g., edges), additional connectivity information is needed. This is provided by the optional fields <code class="code sidskey docutils literal notranslate"><span class="pre">PointRange</span></code> and <code class="code sidskey docutils literal notranslate"><span class="pre">PointList</span></code>; these refer to vertices, edges, faces or cell centers, depending on the values of <code class="code sidskey docutils literal notranslate"><span class="pre">CellDimension</span></code> and <code class="code sidskey docutils literal notranslate"><span class="pre">GridLocation</span></code>. The following table shows these relations. The <code class="code sidskey docutils literal notranslate"><span class="pre">NODE</span></code> element type should not be used in place of the vertex. A vertex <code class="code sidskey docutils literal notranslate"><span class="pre">GridLocation</span></code> should use the <code class="code sidskey docutils literal notranslate"><span class="pre">GridLocation</span> <span class="pre">=</span> <span class="pre">Vertex</span></code> pattern, which implies an indexing on the grid coordinates arrays and not a <code class="code sidskey docutils literal notranslate"><span class="pre">NODE</span> <span class="pre">Elements_t</span></code> array.</p>
<table class="colwidths-given docutils align-center">
<colgroup>
<col style="width: 20%" />
<col style="width: 12%" />
<col style="width: 16%" />
<col style="width: 17%" />
<col style="width: 35%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head" rowspan="2"><p>CellDimension</p></th>
<th class="head" colspan="4"><p>GridLocation</p></th>
</tr>
<tr class="row-even"><th class="head"><p>Vertex</p></th>
<th class="head"><p>EdgeCenter</p></th>
<th class="head"><p>*FaceCenter</p></th>
<th class="head"><p>CellCenter</p></th>
</tr>
</thead>
<tbody>
<tr class="row-odd"><td><p>1</p></td>
<td><p>vertices</p></td>
<td><p>-</p></td>
<td><p>-</p></td>
<td><p>cells (line elements)</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>vertices</p></td>
<td><p>edges</p></td>
<td><p>-</p></td>
<td><p>cells (area elements)</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>vertices</p></td>
<td><p>edges</p></td>
<td><p>faces</p></td>
<td><p>cells (volume elements)</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In the table, <strong>*FaceCenter</strong> stands for the possible types: <code class="code sidskey docutils literal notranslate"><span class="pre">IFaceCenter</span></code>, <code class="code sidskey docutils literal notranslate"><span class="pre">JFaceCenter</span></code>, <code class="code sidskey docutils literal notranslate"><span class="pre">KFaceCenter</span></code>, or <code class="code sidskey docutils literal notranslate"><span class="pre">FaceCenter</span></code>.</p>
</div>
<p>Although intended for edge or face-based solution data for unstructured grids, the fields <code class="code sidskey docutils literal notranslate"><span class="pre">PointRange/List</span></code> may also be used to (redundantly) index vertex and cell-centered data. In all cases, indexing of flow solution data corresponds to the element numbering as defined in the <code class="code sidsref docutils literal notranslate"><span class="pre">Elements_t</span></code> data structures.</p>
<p><code class="code sidsref docutils literal notranslate"><span class="pre">Rind</span></code> is an optional field that indicates the number of rind planes (for structured grids) or rind points or elements (for unstructured grids) included in the data. Its purpose and function are identical to those described for the <code class="code sidsref docutils literal notranslate"><span class="pre">GridCoordinates_t</span></code> structure. Note, however, that the <code class="code sidskey docutils literal notranslate"><span class="pre">Rind</span></code> in this structure is independent of the <code class="code sidskey docutils literal notranslate"><span class="pre">Rind</span></code> contained in <code class="code sidskey docutils literal notranslate"><span class="pre">GridCoordinates_t</span></code>. They are not required to contain the same number of rind planes or elements. Also, the location of any flow-solution rind points is assumed to be consistent with the location of the core flow solution points (e.g., if <code class="code sidskey docutils literal notranslate"><span class="pre">GridLocation</span> <span class="pre">=</span> <span class="pre">CellCenter</span></code>, rind points are assumed to be located at fictitious cell centers).</p>
<p><code class="code sidsref docutils literal notranslate"><span class="pre">DataClass</span></code> defines the default class for data contained in the <code class="code sidsref docutils literal notranslate"><span class="pre">DataArray_t</span></code> entities. For dimensional flow solution data, <code class="code sidsref docutils literal notranslate"><span class="pre">DimensionalUnits</span></code> may be used to describe the system of units employed. If present, these two entities take precedence over the corresponding entities at higher levels of the CGNS hierarchy, following the standard <a class="reference internal" href="hierarchy.html#precedence"><span class="std std-ref">precedence rules</span></a>.</p>
<p>The <code class="code sidsref docutils literal notranslate"><span class="pre">UserDefinedData_t</span></code> data structure allows arbitrary user-defined data to be stored in <code class="code sidskey docutils literal notranslate"><span class="pre">Descriptor_t</span></code> and <code class="code sidskey docutils literal notranslate"><span class="pre">DataArray_t</span></code> children without the restrictions or implicit meanings imposed on these node types at other node locations.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.ListLength">
<span class="n"><span class="pre">FUNCTION</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ListLength</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return value</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
<dt class="field-even">Dependencies</dt>
<dd class="field-even"><p><code class="code sidskey docutils literal notranslate"><span class="pre">PointRange</span></code>, <code class="code sidskey docutils literal notranslate"><span class="pre">PointList</span></code></p>
</dd>
</dl>
<p><code class="code sidskey docutils literal notranslate"><span class="pre">FlowSolution_t</span></code> requires the structure function <code class="code sidskey docutils literal notranslate"><span class="pre">ListLength</span></code>, which is used to specify the number of entities (e.g. vertices) corresponding to a given <code class="code sidskey docutils literal notranslate"><span class="pre">PointRange</span></code> or <code class="code sidskey docutils literal notranslate"><span class="pre">PointList</span></code>. If <code class="code sidskey docutils literal notranslate"><span class="pre">PointRange</span></code> is specified, then <code class="code sidskey docutils literal notranslate"><span class="pre">ListLength</span></code> is obtained from the number of points (inclusive) between the beginning and ending indices of <code class="code sidskey docutils literal notranslate"><span class="pre">PointRange</span></code>. If <code class="code sidskey docutils literal notranslate"><span class="pre">PointList</span></code> is specified, then <code class="code sidskey docutils literal notranslate"><span class="pre">ListLength</span></code> is the number of indices in the list of points. In this situation, <code class="code sidskey docutils literal notranslate"><span class="pre">ListLength</span></code> becomes a user input along with the indices of the list <code class="code sidskey docutils literal notranslate"><span class="pre">PointList</span></code>. By user we mean the application code that is generating the CGNS database.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c">
<span class="n"><span class="pre">FUNCTION</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">DataSize</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return value</dt>
<dd class="field-odd"><p>one-dimensional <code class="docutils literal notranslate"><span class="pre">int</span></code> array of length <code class="code sidskey docutils literal notranslate"><span class="pre">IndexDimension</span></code></p>
</dd>
<dt class="field-even">Dependencies</dt>
<dd class="field-even"><p><code class="code sidskey docutils literal notranslate"><span class="pre">IndexDimension</span></code>, <code class="code sidskey docutils literal notranslate"><span class="pre">VertexSize[]</span></code>, <code class="code sidskey docutils literal notranslate"><span class="pre">CellSize[]</span></code>, <code class="code sidskey docutils literal notranslate"><span class="pre">GridLocation</span></code>, <code class="code sidskey docutils literal notranslate"><span class="pre">Rind</span></code>, <code class="code sidskey docutils literal notranslate"><span class="pre">ListLength[]</span></code></p>
</dd>
</dl>
<p>The function <code class="code sidskey docutils literal notranslate"><span class="pre">DataSize[]</span></code> is the size of flow solution data arrays. If <code class="code sidskey docutils literal notranslate"><span class="pre">Rind</span></code> is absent then <code class="code sidskey docutils literal notranslate"><span class="pre">DataSize</span></code> represents only the core points; it will be the same as <code class="code sidskey docutils literal notranslate"><span class="pre">VertexSize</span></code> or <code class="code sidskey docutils literal notranslate"><span class="pre">CellSize</span></code> depending on <code class="code sidskey docutils literal notranslate"><span class="pre">GridLocation</span></code>. The definition of the function <code class="code sidskey docutils literal notranslate"><span class="pre">DataSize[]</span></code> is as follows:</p>
<div class="highlight-sids notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">PointRange</span><span class="o">/</span><span class="n">PointList</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">present</span><span class="p">)</span><span class="w"> </span><span class="n">then</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">DataSize</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ListLength</span><span class="p">[]</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Rind</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">absent</span><span class="p">)</span><span class="w"> </span><span class="n">then</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">GridLocation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Vertex</span><span class="p">)</span><span class="w"> </span><span class="n">or</span><span class="w"> </span><span class="p">(</span><span class="n">GridLocation</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">absent</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">DataSize</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VertexSize</span><span class="p">[]</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">GridLocation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CellCenter</span><span class="p">)</span><span class="w"> </span><span class="n">then</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">DataSize</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CellSize</span><span class="p">[]</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Rind</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">present</span><span class="p">)</span><span class="w"> </span><span class="n">then</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">GridLocation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Vertex</span><span class="p">)</span><span class="w"> </span><span class="n">or</span><span class="w"> </span><span class="p">(</span><span class="n">GridLocation</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">absent</span><span class="p">)</span><span class="w"> </span><span class="n">then</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">DataSize</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VertexSize</span><span class="p">[]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">,...]</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">GridLocation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CellCenter</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">DataSize</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CellSize</span><span class="p">[]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">,...]</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>where <code class="code docutils literal notranslate"><span class="pre">RindPlanes</span> <span class="pre">=</span> <span class="pre">[a,b,...]</span></code> (see the <code class="code sidsref docutils literal notranslate"><span class="pre">Rind_t</span></code> structure for the definition of <code class="code sidskey docutils literal notranslate"><span class="pre">RindPlanes</span></code>).</p>
</dd></dl>

</section>
<section id="flow-solution-example">
<h2><span class="section-number">7.8. </span>Flow Solution Example<a class="headerlink" href="#flow-solution-example" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>This section contains an example of the flow solution entity, including the designation of grid location and rind planes and data-normalization mechanisms.</p>
</div></blockquote>
<section id="example-flow-solution">
<h3><span class="section-number">7.8.1. </span>Example - Flow Solution<a class="headerlink" href="#example-flow-solution" title="Permalink to this headline">¶</a></h3>
<p>Conservation-equation variables (<span class="math notranslate nohighlight">\(\rho, \rho U, \rho V \text{ and } \rho e_0\)</span>) for a 2-D grid of size <span class="math notranslate nohighlight">\(11 \times 5\)</span>. The flowfield is cell-centered with two planes of rind data. The density, momentum and stagnation energy (<span class="math notranslate nohighlight">\(\rho e_0\)</span>) data is nondimensionalized with respect to a freestream reference state whose quantities are dimensional. The freestream density and pressure are used for normalization; these values are <span class="math notranslate nohighlight">\(1.226\,kg/m^3\)</span> and <span class="math notranslate nohighlight">\(1.0132 \times 10^5\,N/m^2\)</span> (standard atmosphere conditions). The data-name identifier conventions for the conservation-equation variables are <code class="code sidskey docutils literal notranslate"><span class="pre">Density</span></code>, <code class="code sidskey docutils literal notranslate"><span class="pre">MomentumX</span></code>, <code class="code sidskey docutils literal notranslate"><span class="pre">MomentumY</span></code> and <code class="code sidskey docutils literal notranslate"><span class="pre">EnergyStagnationDensity</span></code>.</p>
<div class="highlight-sids notranslate"><div class="highlight"><pre><span></span><span class="c1">!  CellDimension = 2</span>
<span class="c1">!  IndexDimension = 2</span>
<span class="c1">!  VertexSize = [11,5]</span>
<span class="c1">!  CellSize = [10,4]</span>
<span class="kt">FlowSolution_t</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="mi">11</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span><span class="o">&gt;</span><span class="w"> </span><span class="n">FlowExample</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">  </span><span class="p">{{</span><span class="w"></span>
<span class="w">  </span><span class="kt">GridLocation_t</span><span class="w"> </span><span class="n">GridLocation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CellCenter</span><span class="w"> </span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="kt">Rind_t</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Rind</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="p">{{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="n">RindPlanes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="kt">DataClass_t</span><span class="w"> </span><span class="n">DataClass</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NormalizedByDimensional</span><span class="w"> </span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="kt">DimensionalUnits_t</span><span class="w"> </span><span class="n">DimensionalUnits</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="p">{{</span><span class="w"></span>
<span class="w">    </span><span class="n">MassUnits</span><span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="n">Kilogram</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">LengthUnits</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">Meter</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">TimeUnits</span><span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="n">Second</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">TemperatureUnits</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TemperatureUnitsNull</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">AngleUnits</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="n">AngleUnitsNull</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">!  DataType = real</span>
<span class="w">  </span><span class="c1">!  Dimension = 2</span>
<span class="w">  </span><span class="c1">!  DataSize = CellSize + [4,4] = [14,8]</span>
<span class="w">  </span><span class="kt">DataArray_t</span><span class="o">&lt;</span><span class="kt">real</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="mi">14</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Density</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="p">{{</span><span class="w"></span>
<span class="w">    </span><span class="k">Data</span><span class="p">(</span><span class="kt">real</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="mi">14</span><span class="p">,</span><span class="mi">8</span><span class="p">])</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="n">rho</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">),</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">-1</span><span class="p">,</span><span class="mi">12</span><span class="p">),</span><span class="w"> </span><span class="n">j</span><span class="o">=</span><span class="mi">-1</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kt">DataConversion_t</span><span class="w"> </span><span class="n">DataConversion</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">      </span><span class="p">{{</span><span class="w"></span>
<span class="w">      </span><span class="n">ConversionScale</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="mf">1.226</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">ConversionOffset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kt">DimensionalExponents_t</span><span class="w"> </span><span class="n">DimensionalExponents</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">      </span><span class="p">{{</span><span class="w"></span>
<span class="w">      </span><span class="n">MassExponent</span><span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="o">+</span><span class="mi">1</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">LengthExponent</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="mi">-3</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">TimeExponent</span><span class="w">        </span><span class="o">=</span><span class="w">  </span><span class="mi">0</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">TemperatureExponent</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="mi">0</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">AngleExponent</span><span class="w">       </span><span class="o">=</span><span class="w">  </span><span class="mi">0</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="kt">DataArray_t</span><span class="o">&lt;</span><span class="kt">real</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="mi">14</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span><span class="o">&gt;</span><span class="w"> </span><span class="n">MomentumX</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="p">{{</span><span class="w"></span>
<span class="w">    </span><span class="k">Data</span><span class="p">(</span><span class="kt">real</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="mi">14</span><span class="p">,</span><span class="mi">8</span><span class="p">])</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="n">rho_u</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">),</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">-1</span><span class="p">,</span><span class="mi">12</span><span class="p">),</span><span class="w"> </span><span class="n">j</span><span class="o">=</span><span class="mi">-1</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kt">DataConversion_t</span><span class="w"> </span><span class="n">DataConversion</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">      </span><span class="p">{{</span><span class="w"></span>
<span class="w">      </span><span class="n">ConversionScale</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="mf">352.446</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">ConversionOffset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="kt">DataArray_t</span><span class="o">&lt;</span><span class="kt">real</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="mi">14</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span><span class="o">&gt;</span><span class="w"> </span><span class="n">MomentumY</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="p">{{</span><span class="w"></span>
<span class="w">    </span><span class="k">Data</span><span class="p">(</span><span class="kt">real</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="mi">14</span><span class="p">,</span><span class="mi">8</span><span class="p">])</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="n">rho_v</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">),</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">-1</span><span class="p">,</span><span class="mi">12</span><span class="p">),</span><span class="w"> </span><span class="n">j</span><span class="o">=</span><span class="mi">-1</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kt">DataConversion_t</span><span class="w"> </span><span class="n">DataConversion</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">      </span><span class="p">{{</span><span class="w"></span>
<span class="w">      </span><span class="n">ConversionScale</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="mf">352.446</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">ConversionOffset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="kt">DataArray_t</span><span class="o">&lt;</span><span class="kt">real</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="mi">14</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span><span class="o">&gt;</span><span class="w"> </span><span class="n">EnergyStagnationDensity</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="p">{{</span><span class="w"></span>
<span class="w">    </span><span class="k">Data</span><span class="p">(</span><span class="kt">real</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="mi">14</span><span class="p">,</span><span class="mi">8</span><span class="p">])</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="n">rho_e0</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">),</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">-1</span><span class="p">,</span><span class="mi">12</span><span class="p">),</span><span class="w"> </span><span class="n">j</span><span class="o">=</span><span class="mi">-1</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kt">DataConversion_t</span><span class="w"> </span><span class="n">DataConversion</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">      </span><span class="p">{{</span><span class="w"></span>
<span class="w">      </span><span class="n">ConversionScale</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0132</span><span class="n">e</span><span class="o">+</span><span class="mi">05</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">ConversionOffset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>The value of <code class="code sidskey docutils literal notranslate"><span class="pre">GridLocation</span></code> indicates the data is at cell centers, and the value of <code class="code sidskey docutils literal notranslate"><span class="pre">RindPlanes</span></code> specifies two rind planes on each face of the zone. The resulting value of the structure function <code class="code sidskey docutils literal notranslate"><span class="pre">DataSize</span></code> is the number of cells plus four in each coordinate direction; this value is passed to each of the <code class="code sidskey docutils literal notranslate"><span class="pre">DataArray_t</span></code> entities.</p>
<p>Since the data are all nondimensional and normalized by dimensional reference quantities, this information is stated in <code class="code sidskey docutils literal notranslate"><span class="pre">DataClass</span></code> and <code class="code sidskey docutils literal notranslate"><span class="pre">DimensionalUnits</span></code> at the <code class="code sidskey docutils literal notranslate"><span class="pre">FlowSolution_t</span></code> level rather than attaching the appropriate <code class="code sidskey docutils literal notranslate"><span class="pre">DataClass</span></code> and <code class="code sidskey docutils literal notranslate"><span class="pre">DimensionalUnits</span></code> to each <code class="code sidskey docutils literal notranslate"><span class="pre">DataArray_t</span></code> entity. It could possibly be at even higher levels in the hierarchy. The contents of <code class="code sidskey docutils literal notranslate"><span class="pre">DataConversion</span></code> are in each case the denominator of the normalization; this is <span class="math notranslate nohighlight">\(\rho_\infty\)</span> for density, <span class="math notranslate nohighlight">\((p_\infty \rho_\infty)^{1/2}\)</span> for momentum, and <span class="math notranslate nohighlight">\(p_\infty\)</span> for stagnation energy. The dimensional exponents are specified for density. For all the other data, the dimensional exponents are to be inferred from the data-name identifiers.</p>
<p>Note that no information is provided to identify the actual reference state or indicate that it is freestream. This information is not needed for data manipulations involving renormalization or changing the units of the converted raw data.</p>
</section>
</section>
<section id="zone-subregion-structure-definition-zonesubregion-t">
<h2><span class="section-number">7.9. </span>Zone Subregion Structure Definition: <code class="docutils literal notranslate"><span class="pre">ZoneSubRegion_t</span></code><a class="headerlink" href="#zone-subregion-structure-definition-zonesubregion-t" title="Permalink to this headline">¶</a></h2>
<p>The <code class="code sidsref docutils literal notranslate"><span class="pre">ZoneSubRegion_t</span></code> node allows for the ability to give flowfield or other information over a subset of the entire zone in a CGNS file. This subset may be over a portion of a boundary,
or it may be over a portion of the entire field.</p>
<div class="highlight-sids notranslate"><div class="highlight"><pre><span></span><span class="kt">ZoneSubRegion_t</span><span class="o">&lt;</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">IndexDimension</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">CellDimension</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="o">:=</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">List</span><span class="p">(</span><span class="w"> </span><span class="kt">Descriptor_t</span><span class="w"> </span><span class="n">Descriptor1</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">DescriptorN</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w">                         </span><span class="kr">(o)</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">RegionCellDimension</span><span class="w"> </span><span class="p">;</span><span class="w">                                                  </span><span class="kr">(o/d)</span><span class="w"></span>

<span class="w">  </span><span class="kt">GridLocation_t</span><span class="w"> </span><span class="n">GridLocation</span><span class="w"> </span><span class="p">;</span><span class="w">                                              </span><span class="kr">(o/d)</span><span class="w"></span>

<span class="w">  </span><span class="kt">IndexRange_t</span><span class="o">&lt;</span><span class="n">IndexDimension</span><span class="o">&gt;</span><span class="w"> </span><span class="n">PointRange</span><span class="w"> </span><span class="p">;</span><span class="w">                                  </span><span class="kr">(r:o:o:o)</span><span class="w"></span>
<span class="w">  </span><span class="kt">IndexArray_t</span><span class="o">&lt;</span><span class="n">IndexDimension</span><span class="p">,</span><span class="w"> </span><span class="n">ListLength</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">PointList</span><span class="w"> </span><span class="p">;</span><span class="w">                  </span><span class="kr">(o:r:o:o)</span><span class="w"></span>
<span class="w">  </span><span class="kt">Descriptor_t</span><span class="w"> </span><span class="n">BCRegionName</span><span class="w"> </span><span class="p">;</span><span class="w">                                                </span><span class="kr">(o:o:r:o)</span><span class="w"></span>
<span class="w">  </span><span class="kt">Descriptor_t</span><span class="w"> </span><span class="n">GridConnectivityRegionName</span><span class="w"> </span><span class="p">;</span><span class="w">                                  </span><span class="kr">(o:o:o:r)</span><span class="w"></span>

<span class="w">  </span><span class="kt">Rind_t</span><span class="o">&lt;</span><span class="n">IndexDimension</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Rind</span><span class="p">;</span><span class="w">                                               </span><span class="kr">(o/d)</span><span class="w"></span>

<span class="w">  </span><span class="k">List</span><span class="p">(</span><span class="w"> </span><span class="kt">DataArray_t</span><span class="o">&lt;</span><span class="n">DataType</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">ListLength</span><span class="p">[]</span><span class="o">&gt;</span><span class="w"> </span><span class="n">DataArray1</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">DataArrayN</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="kr">(o)</span><span class="w"></span>

<span class="w">  </span><span class="kt">FamilyName_t</span><span class="w"> </span><span class="n">FamilyName</span><span class="w"> </span><span class="p">;</span><span class="w">                                                  </span><span class="kr">(o)</span><span class="w"></span>

<span class="w">  </span><span class="k">List</span><span class="p">(</span><span class="w"> </span><span class="kt">AdditionalFamilyName_t</span><span class="w"> </span><span class="n">AddFamilyName1</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">AddFamilyNameN</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w">         </span><span class="kr">(o)</span><span class="w"></span>

<span class="w">  </span><span class="kt">DataClass_t</span><span class="w"> </span><span class="n">DataClass</span><span class="w"> </span><span class="p">;</span><span class="w">                                                    </span><span class="kr">(o)</span><span class="w"></span>

<span class="w">  </span><span class="kt">DimensionalUnits_t</span><span class="w"> </span><span class="n">DimensionalUnits</span><span class="w"> </span><span class="p">;</span><span class="w">                                      </span><span class="kr">(o)</span><span class="w"></span>

<span class="w">  </span><span class="k">List</span><span class="p">(</span><span class="w"> </span><span class="kt">UserDefinedData_t</span><span class="w"> </span><span class="n">UserDefinedData1</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">UserDefinedDataN</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w">          </span><span class="kr">(o)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ol class="arabic simple">
<li><p>Default names for the <code class="code sidsref docutils literal notranslate"><span class="pre">Descriptor_t</span></code>, <code class="code sidsref docutils literal notranslate"><span class="pre">DataArray_t</span></code>, and <code class="code sidsref docutils literal notranslate"><span class="pre">UserDefinedData_t</span></code> lists are as shown;
users may choose other legitimate names. Legitimate names must be unique within a given instance of <code class="code sidskey docutils literal notranslate"><span class="pre">ZoneSubRegion_t</span></code> and shall not include the names <code class="code sidskey docutils literal notranslate"><span class="pre">RegionCellDimension</span></code>, <code class="code sidskey docutils literal notranslate"><span class="pre">Rind</span></code>, <code class="code sidskey docutils literal notranslate"><span class="pre">PointRange</span></code>, <code class="code sidskey docutils literal notranslate"><span class="pre">PointList</span></code>, <code class="code sidskey docutils literal notranslate"><span class="pre">BCRegionName</span></code>, <code class="code sidskey docutils literal notranslate"><span class="pre">GridConnectivityRegionName</span></code>, <code class="code sidskey docutils literal notranslate"><span class="pre">FamilyName</span></code>, <code class="code sidskey docutils literal notranslate"><span class="pre">DataClass</span></code> or <code class="code sidskey docutils literal notranslate"><span class="pre">DimensionalUnits</span></code>.</p></li>
<li><p><code class="code sidskey docutils literal notranslate"><span class="pre">RegionCellDimension</span></code> must be equal to or less than the cell dimension for the zone. If absent, then its default value is <code class="code sidskey docutils literal notranslate"><span class="pre">CellDimension</span></code>.</p></li>
<li><p><code class="code sidskey docutils literal notranslate"><span class="pre">GridLocation</span></code> has a default value of <code class="code sidskey docutils literal notranslate"><span class="pre">Vertex</span></code> if absent. Permissible values of <code class="code sidskey docutils literal notranslate"><span class="pre">GridLocation</span></code> are determined by <code class="code sidskey docutils literal notranslate"><span class="pre">RegionCellDimension</span></code> (see below). All data within a given instance of <code class="code sidskey docutils literal notranslate"><span class="pre">ZoneSubRegion_t</span></code> must reside at the same grid location.</p></li>
<li><p>The extent of the region and distribution of its data is specified by one of <code class="code sidskey docutils literal notranslate"><span class="pre">PointRange</span></code>, <code class="code sidskey docutils literal notranslate"><span class="pre">PointList</span></code>, <code class="code sidskey docutils literal notranslate"><span class="pre">BCRegionName</span></code>, or <code class="code sidskey docutils literal notranslate"><span class="pre">GridConnectivityRegionName</span></code>. One and only one of these must be specified.</p></li>
</ol>
</div>
<p>The extent of the subregion and the distribution of data within that subregion is determined by <code class="code sidskey docutils literal notranslate"><span class="pre">RegionCellDimension</span></code>, <code class="code sidskey docutils literal notranslate"><span class="pre">GridLocation</span></code>, and one of <code class="code sidskey docutils literal notranslate"><span class="pre">PointRange/List</span></code>, <code class="code sidskey docutils literal notranslate"><span class="pre">BCRegionName</span></code> or <code class="code sidskey docutils literal notranslate"><span class="pre">GridConnectivityRegionName</span></code>. For a 3-D subregion (<code class="code sidskey docutils literal notranslate"><span class="pre">RegionCellDimension</span></code> = 3), data can be located at vertices, edges, face centers or cell centers. For a 2-D subregion (<code class="code sidskey docutils literal notranslate"><span class="pre">RegionCellDimension</span></code> = 2), data can be located at vertices, edges or cell centers (i.e. area elements). It is anticipated that one of the widest uses for <code class="code sidskey docutils literal notranslate"><span class="pre">ZoneSubRegion_t</span></code> will be to store specific boundary-only information. For example, in a 3-D simulation, one may wish to store additional data on surfaces. In this case, the <code class="code sidskey docutils literal notranslate"><span class="pre">RegionCellDimension</span></code> would be set to 2.</p>
<p><code class="code sidskey docutils literal notranslate"><span class="pre">PointRange/List</span></code> refer to vertices, edges, faces or cell centers, depending on the values of <code class="code sidskey docutils literal notranslate"><span class="pre">RegionCellDimension</span></code> and <code class="code sidskey docutils literal notranslate"><span class="pre">GridLocation</span></code>. Note that it is both the dimensionality of the zone (<code class="code sidskey docutils literal notranslate"><span class="pre">CellDimension</span></code>) as well as the dimensionality of the subregion (<code class="code sidskey docutils literal notranslate"><span class="pre">RegionCellDimension</span></code>), that determines the types of elements permissible in <code class="code sidskey docutils literal notranslate"><span class="pre">PointRange/List</span></code>. The following table shows these relations.</p>
<table class="docutils align-center" style="width: 300px">
<colgroup>
<col style="width: 16%" />
<col style="width: 22%" />
<col style="width: 10%" />
<col style="width: 13%" />
<col style="width: 14%" />
<col style="width: 26%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head" rowspan="2"><p>CellDimension</p></th>
<th class="head" rowspan="2"><p>RegionCellDimension</p></th>
<th class="head" colspan="4"><p>GridLocation</p></th>
</tr>
<tr class="row-even"><th class="head"><p>Vertex</p></th>
<th class="head"><p>EdgeCenter</p></th>
<th class="head"><p>*FaceCenter</p></th>
<th class="head"><p>CellCenter</p></th>
</tr>
</thead>
<tbody>
<tr class="row-odd"><td><p>1</p></td>
<td><p>1</p></td>
<td><p>vertices</p></td>
<td><p>-</p></td>
<td><p>-</p></td>
<td><p>cells (line elements)</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>1</p></td>
<td><p>vertices</p></td>
<td><p>edges</p></td>
<td><p>-</p></td>
<td><p>-</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>2</p></td>
<td><p>vertices</p></td>
<td><p>edges</p></td>
<td><p>-</p></td>
<td><p>cells (area elements)</p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p>1</p></td>
<td><p>vertices</p></td>
<td><p>edges</p></td>
<td><p>-</p></td>
<td><p>-</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>2</p></td>
<td><p>vertices</p></td>
<td><p>edges</p></td>
<td><p>faces</p></td>
<td><p>-</p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p>3</p></td>
<td><p>vertices</p></td>
<td><p>edges</p></td>
<td><p>faces</p></td>
<td><p>cells (volume elements)</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In the table, <strong>*FaceCenter</strong> stands for the possible types: <code class="code sidskey docutils literal notranslate"><span class="pre">IFaceCenter</span></code>, <code class="code sidskey docutils literal notranslate"><span class="pre">JFaceCenter</span></code>, <code class="code sidskey docutils literal notranslate"><span class="pre">KFaceCenter</span></code>, or <code class="code sidskey docutils literal notranslate"><span class="pre">FaceCenter</span></code>.</p>
</div>
<p>For both structured and unstructured grids, <code class="code sidskey docutils literal notranslate"><span class="pre">GridLocation</span> <span class="pre">=</span> <span class="pre">Vertex</span></code> means that <code class="code sidskey docutils literal notranslate"><span class="pre">PointRange/List</span></code> refers to vertex indices. For structured grids, edges, faces and cell centers are indexed using the minimum of the connecting vertex indices, as described in the section <a class="reference internal" href="convention.html#structgrid"><span class="std std-ref">Structured Grid Notation and Indexing Conventions</span></a>. For unstructured grids, edges, faces and cell centers are indexed using their element numbering, as defined in the <code class="code sidsref docutils literal notranslate"><span class="pre">Elements_t</span></code> data structures.</p>
<p>If the vertices or elements of the subregion are continuously numbered, then <code class="code sidskey docutils literal notranslate"><span class="pre">PointRange</span></code> may be used. Otherwise, <code class="code sidskey docutils literal notranslate"><span class="pre">PointList</span></code> should be used to list the vertices/elements. Alternatively, if the data locations and range of the subregion coincide with an existing BC region or zone-to-zone GridConnectivity region, then <code class="code sidskey docutils literal notranslate"><span class="pre">BCRegionName</span></code> or <code class="code sidskey docutils literal notranslate"><span class="pre">GridConnectivityRegionName</span></code> may be used. <code class="code sidskey docutils literal notranslate"><span class="pre">BCRegionName</span></code> is a string giving the name of an existing <code class="code sidsref docutils literal notranslate"><span class="pre">BC_t</span></code> node of the current zone. <code class="code sidskey docutils literal notranslate"><span class="pre">GridConnectivityRegionName</span></code> is a string giving the name of an existing <code class="code sidsref docutils literal notranslate"><span class="pre">GridConnectivity1to1_t</span></code> or <code class="code sidsref docutils literal notranslate"><span class="pre">GridConnectivity_t</span></code> node of the current zone. The name referred to should be unambiguous.</p>
<p>Consistent with <code class="code sidsref docutils literal notranslate"><span class="pre">FlowSolution_t</span></code>, the subregion’s solution data is stored in the list of <code class="code sidsref docutils literal notranslate"><span class="pre">DataArray_t</span></code> entities; each <code class="code sidskey docutils literal notranslate"><span class="pre">DataArray_t</span></code> structure entity contains a single quantity. Standardized data-name identifiers for solution quantities are described in the section <span class="xref std std-ref">Conventions for Data-Name Identifiers</span>. As noted above, all solution data within a given subregion must reside at the same grid location.</p>
<p><code class="code sidsref docutils literal notranslate"><span class="pre">DataClass</span></code> defines the default class for data contained in the <code class="code sidskey docutils literal notranslate"><span class="pre">DataArray_t</span></code> entities. For dimensional flow solution data, <code class="code sidsref docutils literal notranslate"><span class="pre">DimensionalUnits</span></code> may be used to describe the system of units employed. If present, these two entities take precedence over the corresponding entities at higher levels of the CGNS hierarchy, following the standard <a class="reference internal" href="hierarchy.html#precedence"><span class="std std-ref">precedence rules</span></a>.</p>
<p><code class="code sidskey docutils literal notranslate"><span class="pre">ZoneSubRegion_t</span></code> requires the structure function <code class="code sidsref docutils literal notranslate"><span class="pre">ListLength[]</span></code>, which is used to specify the number of data points (e.g. vertices, cell centers, face centers, edge centers) corresponding to the given <code class="code sidskey docutils literal notranslate"><span class="pre">PointRange/List</span></code>. If <code class="code sidskey docutils literal notranslate"><span class="pre">PointRange</span></code> is specified, then <code class="code sidskey docutils literal notranslate"><span class="pre">ListLength</span></code> is obtained from the number of points (inclusive) between the beginning and ending indices of <code class="code sidskey docutils literal notranslate"><span class="pre">PointRange</span></code>. If <code class="code sidskey docutils literal notranslate"><span class="pre">PointList</span></code> is specified, then <code class="code sidskey docutils literal notranslate"><span class="pre">ListLength</span></code> is the number of indices in the list of points. In this situation, <code class="code sidskey docutils literal notranslate"><span class="pre">ListLength</span></code> becomes a user input along with the indices of the list <code class="code sidskey docutils literal notranslate"><span class="pre">PointList</span></code>. By <em>user</em> we mean the application code that is generating the CGNS database.</p>
<p><code class="code sidsref docutils literal notranslate"><span class="pre">Rind</span></code> is an optional field that indicates the number of rind planes (for structured grids) or rind points (for unstructured grids). If <code class="code sidskey docutils literal notranslate"><span class="pre">Rind</span></code> is absent, then the <code class="code sidskey docutils literal notranslate"><span class="pre">DataArray_t</span></code> structure entities contain only core data of length <code class="code sidskey docutils literal notranslate"><span class="pre">ListLength</span></code>, as defined for this region. If <code class="code sidskey docutils literal notranslate"><span class="pre">Rind</span></code> is present, it will provide information on the number of rind elements, in addition to the <code class="code sidskey docutils literal notranslate"><span class="pre">ListLength</span></code>, that are contained in the <code class="code sidskey docutils literal notranslate"><span class="pre">DataArray_t</span></code> structures. The bottom line is that <code class="code sidskey docutils literal notranslate"><span class="pre">Rind</span></code> simply adds a specified number to <code class="code sidskey docutils literal notranslate"><span class="pre">ListLength</span></code>, as used by the <code class="code sidskey docutils literal notranslate"><span class="pre">DataArray_t</span></code> structures.</p>
<p>The <code class="code sidsref docutils literal notranslate"><span class="pre">UserDefinedData_t</span></code> data structure allows arbitrary user-defined data to be stored.</p>
<p>There may be multiple instances of <code class="code sidskey docutils literal notranslate"><span class="pre">ZoneSubRegion_t</span></code> in a given zone. These may simply be multiple regions defined for a single solution, or they may be associated with different times / different solutions in a time-dependent simulation (in which case <code class="code sidsref docutils literal notranslate"><span class="pre">ZoneIterativeData_t</span></code> should be used to associate them).</p>
<p>All <code class="code sidskey docutils literal notranslate"><span class="pre">FamilyName</span></code> and <code class="code sidskey docutils literal notranslate"><span class="pre">AdditionalFamilyName</span></code> entries should respect the rules defined in <span class="xref std std-ref">Base Level Families</span> and <code class="code sidsref docutils literal notranslate"><span class="pre">Zone_t</span></code>.</p>
</section>
<section id="zone-subregion-examples">
<h2><span class="section-number">7.10. </span>Zone Subregion Examples<a class="headerlink" href="#zone-subregion-examples" title="Permalink to this headline">¶</a></h2>
<p>This section contains four examples of Zone Subregions, including the use of <code class="code sidskey docutils literal notranslate"><span class="pre">PointList</span></code>, <code class="code sidskey docutils literal notranslate"><span class="pre">PointRange</span></code> and <code class="code sidskey docutils literal notranslate"><span class="pre">BCRegionName</span></code>.</p>
<section id="example-volume-subregion-for-a-structured-grid">
<h3><span class="section-number">7.10.1. </span>Example - Volume Subregion for a Structured Grid<a class="headerlink" href="#example-volume-subregion-for-a-structured-grid" title="Permalink to this headline">¶</a></h3>
<p>For this example, it is assumed that a 1-zone 3-D structured grid exists of size (<span class="math notranslate nohighlight">\(197\times97\times33\)</span>). Inside of this zone, the user wishes to output a special subset region of interior data (say, temperature and kinematic viscosity) at the specific cell-center locations <span class="math notranslate nohighlight">\(i = 121-149\)</span>, <span class="math notranslate nohighlight">\(j = 17-45\)</span>, <span class="math notranslate nohighlight">\(k = 21-23\)</span>. Even though this same data may possibly exist under <code class="code sidskey docutils literal notranslate"><span class="pre">FlowSolution_t</span></code> (which holds the flowfield data for the entire zone), this particular location may represent a special region of interest where the user wants to focus attention or output different types of flowfield variables or user-defined data. Note that for structured grids, the location list always references grid nodes; in this case with <code class="code sidskey docutils literal notranslate"><span class="pre">GridLocation</span> <span class="pre">=</span> <span class="pre">Cellcenter</span></code> the cell centers are indexed by the minimum <span class="math notranslate nohighlight">\(i\)</span>, <span class="math notranslate nohighlight">\(j\)</span>, and <span class="math notranslate nohighlight">\(k\)</span> indices of the connecting vertices.</p>
<p>Under <code class="code sidskey docutils literal notranslate"><span class="pre">Zone_t</span></code>:</p>
<div class="highlight-sids notranslate"><div class="highlight"><pre><span></span><span class="kt">ZoneSubRegion_t</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Region1</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">  </span><span class="p">{{</span><span class="w"></span>
<span class="w">  </span><span class="kt">GridLocation_t</span><span class="w"> </span><span class="n">GridLocation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CellCenter</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">RegionCellDimension</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">IndexRange_t</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">PointRange</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="p">{{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="n">Begin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">121</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">21</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="n">End</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">149</span><span class="p">,</span><span class="mi">45</span><span class="p">,</span><span class="mi">21</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="p">}};</span><span class="w"></span>

<span class="w">  </span><span class="c1">! ListLength = (149-121+1)*(45-17+1)*(23-21+1) = 29*29*3 = 2523</span>
<span class="w">  </span><span class="kt">DataArray_t</span><span class="o">&lt;</span><span class="kt">real</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2523</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Temperature</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="p">{{</span><span class="w"></span>
<span class="w">    </span><span class="k">Data</span><span class="p">(</span><span class="kt">real</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2523</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">temperature</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">cell</span><span class="w"> </span><span class="n">centers</span><span class="w"> </span><span class="n">specified</span><span class="w"></span>
<span class="w">    </span><span class="p">}}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">DataArray_t</span><span class="o">&lt;</span><span class="kt">real</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2523</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ViscosityKinematic</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="p">{{</span><span class="w"></span>
<span class="w">    </span><span class="k">Data</span><span class="p">(</span><span class="kt">real</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2523</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kinematic</span><span class="w"> </span><span class="n">viscosity</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">cell</span><span class="w"> </span><span class="n">centers</span><span class="w"> </span><span class="n">specified</span><span class="w"></span>
<span class="w">    </span><span class="p">}}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}}</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="c1">! end Region1</span>
</pre></div>
</div>
</section>
<section id="example-volume-subregion-for-an-unstructured-grid">
<h3><span class="section-number">7.10.2. </span>Example - Volume Subregion for an Unstructured Grid<a class="headerlink" href="#example-volume-subregion-for-an-unstructured-grid" title="Permalink to this headline">¶</a></h3>
<p>This example is like the previous one, except it is for an unstructured zone. Inside of this zone, the user wishes to output a special subset region of data (say, temperature and kinematic viscosity) at a specific list of 2523 element cell-center locations, located somewhere within the (larger) field of elements. Recall that when <code class="code sidskey docutils literal notranslate"><span class="pre">GridLocation</span></code> is anything other than <code class="code sidskey docutils literal notranslate"><span class="pre">Vertex</span></code> in conjunction with unstructured grids, then the location list represents element numbers and not grid node numbers.</p>
<p>Under <code class="code sidskey docutils literal notranslate"><span class="pre">Zone_t</span></code>:</p>
<div class="highlight-sids notranslate"><div class="highlight"><pre><span></span><span class="kt">ZoneSubRegion_t</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Region1</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">  </span><span class="p">{{</span><span class="w"></span>
<span class="w">  </span><span class="kt">GridLocation_t</span><span class="w"> </span><span class="n">GridLocation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CellCenter</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">RegionCellDimension</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">IndexArray_t</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">2523</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">PointList</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="p">{{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="n">ElementList</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="mi">3</span><span class="o">-</span><span class="n">D</span><span class="w"> </span><span class="n">element</span><span class="w"> </span><span class="n">numbers</span><span class="w"> </span><span class="n">where</span><span class="w"> </span><span class="n">region</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="n">given</span><span class="w"></span>
<span class="w">    </span><span class="p">}}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">! ListLength = length of the element list = 2523</span>
<span class="w">  </span><span class="kt">DataArray_t</span><span class="o">&lt;</span><span class="kt">real</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2523</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Temperature</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="p">{{</span><span class="w"></span>
<span class="w">    </span><span class="k">Data</span><span class="p">(</span><span class="kt">real</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2523</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">temperature</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">element</span><span class="w"> </span><span class="n">cell</span><span class="w"> </span><span class="n">centers</span><span class="w"> </span><span class="n">specified</span><span class="w"></span>
<span class="w">    </span><span class="p">}}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">DataArray_t</span><span class="o">&lt;</span><span class="kt">real</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2523</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ViscosityKinematic</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="p">{{</span><span class="w"></span>
<span class="w">    </span><span class="k">Data</span><span class="p">(</span><span class="kt">real</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2523</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kinematic</span><span class="w"> </span><span class="n">viscosity</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">element</span><span class="w"> </span><span class="n">cell</span><span class="w"> </span><span class="n">centers</span><span class="w"> </span><span class="n">specified</span><span class="w"></span>
<span class="w">    </span><span class="p">}}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}}</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="c1">! end Region1</span>
</pre></div>
</div>
</section>
<section id="example-surface-subregion-for-an-unstructured-grid">
<h3><span class="section-number">7.10.3. </span>Example - Surface Subregion for an Unstructured Grid<a class="headerlink" href="#example-surface-subregion-for-an-unstructured-grid" title="Permalink to this headline">¶</a></h3>
<p>In this example, boundary data is output on a 2-D surface subregion of a 3-D problem. Because this is data on a topologically 2-D boundary (in a 3-D simulation), <code class="code sidskey docutils literal notranslate"><span class="pre">RegionCellDimension</span></code> is set to 2. <code class="code sidskey docutils literal notranslate"><span class="pre">GridLocation</span></code> is specified as <code class="code sidskey docutils literal notranslate"><span class="pre">FaceCenter</span></code>. Recall that when <code class="code sidskey docutils literal notranslate"><span class="pre">GridLocation</span></code> is anything other than <code class="code sidskey docutils literal notranslate"><span class="pre">Vertex</span></code> in conjunction with unstructured grids, then the location list represents element numbers and not grid node numbers. Thus, the <code class="code sidskey docutils literal notranslate"><span class="pre">PointList/Range</span></code> indicates particular surface elements (or boundary elements) that need to have been defined in the file under their own <code class="code sidskey docutils literal notranslate"><span class="pre">Elements_t</span></code> node(s), separate from the 3-D volume elements that make up the grid. In this case, we assume that the surface element numbers at which we are outputting data are 5568 through 5592 inclusive. Because the numbers occur in sequential order, we can make use of <code class="code sidskey docutils literal notranslate"><span class="pre">PointRange</span></code>.</p>
<p>Under <code class="code sidskey docutils literal notranslate"><span class="pre">Zone_t</span></code>:</p>
<div class="highlight-sids notranslate"><div class="highlight"><pre><span></span><span class="kt">ZoneSubRegion_t</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Region1</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">  </span><span class="p">{{</span><span class="w"></span>
<span class="w">  </span><span class="kt">GridLocation_t</span><span class="w"> </span><span class="n">GridLocation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FaceCenter</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">RegionCellDimension</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">IndexArray_t</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">25</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">PointRange</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="p">{{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="n">Begin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">5568</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="n">End</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">5592</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="p">}}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">! ListLength = length of the element list = 25</span>
<span class="w">  </span><span class="kt">DataArray_t</span><span class="o">&lt;</span><span class="kt">real</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">25</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Temperature</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="p">{{</span><span class="w"></span>
<span class="w">    </span><span class="k">Data</span><span class="p">(</span><span class="kt">real</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">25</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">temperature</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">specific</span><span class="w"> </span><span class="n">face</span><span class="w"> </span><span class="n">element</span><span class="w"> </span><span class="n">locations</span><span class="w"> </span><span class="n">specified</span><span class="w"></span>
<span class="w">    </span><span class="p">}}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">DataArray_t</span><span class="o">&lt;</span><span class="kt">real</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">25</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ViscosityKinematic</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="p">{{</span><span class="w"></span>
<span class="w">    </span><span class="k">Data</span><span class="p">(</span><span class="kt">real</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">25</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kinematic</span><span class="w"> </span><span class="n">viscosity</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">specific</span><span class="w"> </span><span class="n">face</span><span class="w"> </span><span class="n">element</span><span class="w"> </span><span class="n">locations</span><span class="w"> </span><span class="n">specified</span><span class="w"></span>
<span class="w">    </span><span class="p">}}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}}</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="c1">! end Region1</span>
</pre></div>
</div>
</section>
<section id="example-surface-subregion-utilizing-bc-information">
<h3><span class="section-number">7.10.4. </span>Example - Surface Subregion Utilizing BC Information<a class="headerlink" href="#example-surface-subregion-utilizing-bc-information" title="Permalink to this headline">¶</a></h3>
<p>In this example, boundary data is output at the same locations where the BCs are specified in a particular <code class="code sidskey docutils literal notranslate"><span class="pre">BC_t</span></code> node (in this case the <code class="code sidskey docutils literal notranslate"><span class="pre">ListLength</span></code> is 25). Note that because this is data on a topologically 2-D boundary (in a 3-D simulation), <code class="code sidskey docutils literal notranslate"><span class="pre">RegionCellDimension</span></code> is set to 2. <code class="code sidskey docutils literal notranslate"><span class="pre">GridLocation</span></code> is not specified, because it is inherited from the <code class="code sidskey docutils literal notranslate"><span class="pre">BC_t</span></code> node along with the <code class="code sidskey docutils literal notranslate"><span class="pre">ListLength</span></code>.</p>
<p>Under <code class="code sidskey docutils literal notranslate"><span class="pre">Zone_t</span></code>:</p>
<div class="highlight-sids notranslate"><div class="highlight"><pre><span></span><span class="kt">ZoneSubRegion_t</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Region1</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">  </span><span class="p">{{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">RegionCellDimension</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">Descriptor_t</span><span class="w"> </span><span class="n">BCRegionName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;name of a ZoneBC/BC_t node&quot;</span><span class="w"> </span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">! ListLength = length of the point/element list from BC_t = 25</span>
<span class="w">  </span><span class="kt">DataArray_t</span><span class="o">&lt;</span><span class="kt">real</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">25</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Temperature</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="p">{{</span><span class="w"></span>
<span class="w">    </span><span class="k">Data</span><span class="p">(</span><span class="kt">real</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">25</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">temperature</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">specific</span><span class="w"> </span><span class="n">BC</span><span class="w"> </span><span class="n">locations</span><span class="w"> </span><span class="n">specified</span><span class="w"></span>
<span class="w">    </span><span class="p">}}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">DataArray_t</span><span class="o">&lt;</span><span class="kt">real</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">25</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ViscosityKinematic</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="p">{{</span><span class="w"></span>
<span class="w">    </span><span class="k">Data</span><span class="p">(</span><span class="kt">real</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">25</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kinematic</span><span class="w"> </span><span class="n">viscosity</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">specific</span><span class="w"> </span><span class="n">BC</span><span class="w"> </span><span class="n">locations</span><span class="w"> </span><span class="n">specified</span><span class="w"></span>
<span class="w">    </span><span class="p">}}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}}</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="c1">! end Region1</span>
</pre></div>
</div>
</section>
</section>
</section>


          </div>
            
  <div class="footer-relations">
    
      <div class="pull-left">
        <a class="btn btn-default" href="hierarchy.html" title="previous chapter (use the left arrow)"><span class="section-number">6. </span>Hierarchical Structures</a>
      </div>
    
      <div class="pull-right">
        <a class="btn btn-default" href="multizone.html" title="next chapter (use the right arrow)"><span class="section-number">8. </span>Multizone Interface Connectivity</a>
      </div>
    </div>
    <div class="clearer"></div>
  
        </div>
        <div class="clearfix"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="multizone.html" title="8. Multizone Interface Connectivity"
             >next</a> |</li>
        <li class="right" >
          <a href="hierarchy.html" title="6. Hierarchical Structures"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">CGNS Official Web Site</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../standard.html" >Standard Specification</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="CGNS_SIDS.html" >CGNS/SIDS - Standard Interface Data Structures</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">7. </span>Grid Coordinates, Elements, and Flow Solution</a></li> 
      </ul>
    </div>
<script type="text/javascript">
  $("#mobile-toggle a").click(function () {
    $("#left-column").toggle();
  });
</script>
<script type="text/javascript" src="../../_static/js/bootstrap.js"></script>
  <div class="footer">
    &copy; Copyright 1991-2020, CGNS Steering Commmittee. Created using <a href="http://sphinx.pocoo.org/">Sphinx</a>.
  </div>
  </body>
</html>