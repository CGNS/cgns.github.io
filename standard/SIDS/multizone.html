
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <!-- Licensed under the Apache 2.0 License -->
  <link rel="stylesheet" type="text/css" href="../../_static/fonts/open-sans/stylesheet.css" />
  <!-- Licensed under the SIL Open Font License -->
  <link rel="stylesheet" type="text/css" href="../../_static/fonts/source-serif-pro/source-serif-pro.css" />
  <link rel="stylesheet" type="text/css" href="../../_static/css/bootstrap.min.css" />
  <link rel="stylesheet" type="text/css" href="../../_static/css/bootstrap-theme.min.css" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
    <title>8. Multizone Interface Connectivity &#8212; CGNS Official Web Site</title>
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/guzzle.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/css/filemap.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/css/math_override.css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="../../_static/CGNS_empty.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="9. Boundary Conditions" href="boundary.html" />
    <link rel="prev" title="7. Grid Coordinates, Elements, and Flow Solution" href="grid.html" />
  
  <link rel="apple-touch-icon" href="../../_static/CGNS_empty.svg" />
  
   

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="boundary.html" title="9. Boundary Conditions"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="grid.html" title="7. Grid Coordinates, Elements, and Flow Solution"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">CGNS Official Web Site</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../standard.html" >Standard Specification</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="CGNS_SIDS.html" accesskey="U">CGNS/SIDS - Standard Interface Data Structures</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">8. </span>Multizone Interface Connectivity</a></li> 
      </ul>
    </div>
    <div class="container-wrapper">

      <div id="mobile-toggle">
        <a href="#"><span class="glyphicon glyphicon-align-justify" aria-hidden="true"></span></a>
      </div>
  <div id="left-column">
    <div class="sphinxsidebar">
<div class="sidebar-block">
  <div class="sidebar-wrapper">
    <div id="main-search">
      <form class="form-inline" action="../../search.html" method="GET" role="form">
        <div class="input-group">
          <input name="q" type="text" class="form-control" placeholder="Search...">
        </div>
        <input type="hidden" name="check_keywords" value="yes" />
        <input type="hidden" name="area" value="default" />
      </form>
    </div>
  </div>
</div>
<div class="sidebar-block">
  <div class="sidebar-wrapper">
    <h2>Contents</h2>
    <div class="sidebar-localtoc">
      <ul>
<li><a class="reference internal" href="#">8. Multizone Interface Connectivity</a><ul>
<li><a class="reference internal" href="#zonal-connectivity-structure-definition-zonegridconnectivity-t">8.1. Zonal Connectivity Structure Definition: <code class="docutils literal notranslate"><span class="pre">ZoneGridConnectivity_t</span></code></a></li>
<li><a class="reference internal" href="#to-1-interface-connectivity-structure-definition-gridconnectivity1to1-t">8.2. 1-to-1 Interface Connectivity Structure Definition: <code class="docutils literal notranslate"><span class="pre">GridConnectivity1to1_t</span></code></a></li>
<li><a class="reference internal" href="#to-1-interface-connectivity-examples">8.3. 1-to-1 Interface Connectivity Examples</a><ul>
<li><a class="reference internal" href="#example-1-to-1-abutting-of-complete-faces">8.3.1. Example - 1-to-1 Abutting of Complete Faces</a></li>
<li><a class="reference internal" href="#example-1-to-1-abutting-complete-face-to-a-subset-of-a-face">8.3.2. Example - 1-to-1 Abutting, Complete Face to a Subset of a Face</a></li>
</ul>
</li>
<li><a class="reference internal" href="#general-interface-connectivity-structure-definition-gridconnectivity-t">8.4. General Interface Connectivity Structure Definition: <code class="docutils literal notranslate"><span class="pre">GridConnectivity_t</span></code></a></li>
<li><a class="reference internal" href="#general-interface-connectivity-examples">8.5. General Interface Connectivity Examples</a><ul>
<li><a class="reference internal" href="#example-structured-abutting-zones">8.5.1. Example - Structured Abutting Zones</a></li>
<li><a class="reference internal" href="#example-unstructured-abutting-zones-hexa-8-donor-cell">8.5.2. Example - Unstructured Abutting Zones, HEXA_8 Donor Cell</a></li>
<li><a class="reference internal" href="#example-unstructured-abutting-zones-tri-3-donor-cell">8.5.3. Example - Unstructured Abutting Zones, TRI_3 Donor Cell</a></li>
</ul>
</li>
<li><a class="reference internal" href="#grid-connectivity-property-structure-definition-gridconnectivityproperty-t">8.6. Grid Connectivity Property Structure Definition: <code class="docutils literal notranslate"><span class="pre">GridConnectivityProperty_t</span></code></a><ul>
<li><a class="reference internal" href="#periodic-interface-structure-definition-periodic-t">8.6.1. Periodic Interface Structure Definition: <code class="docutils literal notranslate"><span class="pre">Periodic_t</span></code></a></li>
<li><a class="reference internal" href="#average-interface-structure-definition-averageinterface-t">8.6.2. Average Interface Structure Definition: <code class="docutils literal notranslate"><span class="pre">AverageInterface_t</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#overset-grid-holes-structure-definition-oversetholes-t">8.7. Overset Grid Holes Structure Definition: <code class="docutils literal notranslate"><span class="pre">OversetHoles_t</span></code></a></li>
</ul>
</li>
</ul>

    </div>
  </div>
</div>
      
    </div>
  </div>
        <div id="right-column">
          
          <div role="navigation" aria-label="breadcrumbs navigation">
            <ol class="breadcrumb">
              <li><a href="../../index.html">Docs</a></li>
              
                <li><a href="../../standard.html">Standard Specification</a></li>
              
                <li><a href="CGNS_SIDS.html">CGNS/SIDS - Standard Interface Data Structures</a></li>
              
              <li><span class="section-number">8. </span>Multizone Interface Connectivity</li>
            </ol>
          </div>
          
          <div class="document clearer body">
            
  <div class="section" id="multizone-interface-connectivity">
<span id="sids-connectivity"></span><h1><span class="section-number">8. </span>Multizone Interface Connectivity<a class="headerlink" href="#multizone-interface-connectivity" title="Permalink to this headline">¶</a></h1>
<p>This section defines structures for describing multizone interface connectivity for <a class="reference internal" href="convention.html#interfaces"><span class="std std-ref">1-to-1 abutting, mismatched abutting, and overset type interfaces</span></a>.
All interface connectivity information pertaining to a given zone is grouped together in a <code class="code sidsref docutils literal notranslate"><span class="pre">ZoneGridConnectivity_t</span></code> structure entity; this in turn is contained in a <span class="xref std std-ref">zone structure entity</span>.</p>
<p>Before presentation of the structure definitions, a few design features require comment.
All indices used to describe interfaces are the dimensionality (<code class="code sidskey docutils literal notranslate"><span class="pre">IndexDimension</span></code>) of the grid, even when they are used to describe lower-dimensional zonal boundaries for abutting interfaces. The alternative for structured zones that was not chosen is to use lower-dimensional indices for lower-dimensional interfaces (e.g., for a 3-D grid, use two-dimensional indices for describing grid planes that are interfaces). Both alternatives offer trade-offs. The lower-dimensional indices require cyclic notation conventions and additional identification of face location; whereas, full-dimensional indices result in one redundant index component when describing points along a grid plane. We decided that full-dimensional indices would be more usable and less error prone in actual implementation.</p>
<p>A major consequence of this decision is that connectivity information for describing mismatched abutting interfaces and overset interfaces can be merged into a single structure, <code class="code sidsref docutils literal notranslate"><span class="pre">GridConnectivity_t</span></code>.
In fact, this single structure type can be used to describe all zonal interfaces.</p>
<p>A second design choice was to duplicate all 1-to-1 abutting interface information within the CGNS database. It is possible to describe a given 1-to-1 interface with a single set of connectivity data. In contrast, mismatched and overset interfaces require different connectivity information when the roles of receiver and donor zones are interchanged. Therefore, a given mismatched or overset interface requires two sets of connectivity data within the database. The decision to force two sets of connectivity data (one contained in each of the <code class="code sidskey docutils literal notranslate"><span class="pre">Zone_t</span></code> entities for the two adjacent zones)for each 1-to-1 interface makes the connectivity structures for all interface types look and function similarly. It also fits better with the zone-by-zone hierarchy chosen for the CGNS database. The minor penalty in data duplication was deemed worth the advantages gained.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is a CGNS design intent that a given zone boundary segment or location should at most be defined (or covered) by either a boundary condition or a multizone interface connectivity, but not by both.</p>
</div>
<div class="section" id="zonal-connectivity-structure-definition-zonegridconnectivity-t">
<h2><span class="section-number">8.1. </span>Zonal Connectivity Structure Definition: <code class="docutils literal notranslate"><span class="pre">ZoneGridConnectivity_t</span></code><a class="headerlink" href="#zonal-connectivity-structure-definition-zonegridconnectivity-t" title="Permalink to this headline">¶</a></h2>
<p>All multizone interface grid connectivity information pertaining to a given zone is contained in the <code class="code sidskey docutils literal notranslate"><span class="pre">ZoneGridConnectivity_t</span></code> structure.
This includes abutting interfaces (1-to-1 and general mismatched), overset-grid interfaces, and overset-grid holes.</p>
<div class="highlight-sids notranslate"><div class="highlight"><pre><span></span><span class="kt">ZoneGridConnectivity_t</span><span class="o">&lt;</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">IndexDimension</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">CellDimension</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="o">:=</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">List</span><span class="p">(</span><span class="w"> </span><span class="kt">Descriptor_t</span><span class="w"> </span><span class="n">Descriptor1</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">DescriptorN</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w">                 </span><span class="kr">(o)</span><span class="w"></span>

<span class="w">  </span><span class="k">List</span><span class="p">(</span><span class="w"> </span><span class="kt">GridConnectivity1to1_t</span><span class="o">&lt;</span><span class="n">IndexDimension</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">        </span><span class="n">GridConnectivity1to11</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">GridConnectivity1to1N</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w">          </span><span class="kr">(o)</span><span class="w"></span>

<span class="w">  </span><span class="k">List</span><span class="p">(</span><span class="w"> </span><span class="kt">GridConnectivity_t</span><span class="o">&lt;</span><span class="n">IndexDimension</span><span class="p">,</span><span class="w"> </span><span class="n">CellDimension</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">        </span><span class="n">GridConnectivity1</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">GridConnectivityN</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w">                  </span><span class="kr">(o)</span><span class="w"></span>

<span class="w">  </span><span class="k">List</span><span class="p">(</span><span class="w"> </span><span class="kt">OversetHoles_t</span><span class="o">&lt;</span><span class="n">IndexDimension</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">        </span><span class="n">OversetHoles1</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">OversetHolesN</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w">                          </span><span class="kr">(o)</span><span class="w"></span>

<span class="w">  </span><span class="k">List</span><span class="p">(</span><span class="w"> </span><span class="kt">UserDefinedData_t</span><span class="w"> </span><span class="n">UserDefinedData1</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">UserDefinedDataN</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w">  </span><span class="kr">(o)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Default names for the <code class="code sidsref docutils literal notranslate"><span class="pre">Descriptor_t</span></code>, <code class="code sidsref docutils literal notranslate"><span class="pre">GridConnectivity1to1_t</span></code>, <code class="code sidsref docutils literal notranslate"><span class="pre">GridConnectivity_t</span></code>, <code class="code sidsref docutils literal notranslate"><span class="pre">OversetHoles_t</span></code>, and <code class="code sidsref docutils literal notranslate"><span class="pre">UserDefinedData_t</span></code> lists are as shown; users may choose other legitimate names. Legitimate names must be unique within a given instance of ZoneGridConnectivity_t.</p>
<p>All lists within the <code class="code sidskey docutils literal notranslate"><span class="pre">ZoneGridConnectivity_t</span></code> structure may be empty.</p>
</div>
<p><code class="code sidskey docutils literal notranslate"><span class="pre">ZoneGridConnectivity_t</span></code> requires two structure parameters, <code class="code sidskey docutils literal notranslate"><span class="pre">IndexDimension</span></code>, which is passed onto all connectivity substructures, and <code class="code sidskey docutils literal notranslate"><span class="pre">CellDimension</span></code>, which is passed to <code class="code sidsref docutils literal notranslate"><span class="pre">GridConnectivity_t</span></code> only.</p>
<p>Connectivity information for 1-to-1 or matched multizone interfaces is contained in the <code class="code sidsref docutils literal notranslate"><span class="pre">GridConnectivity1to1_t</span></code> structure.
Abutting and overset connectivity is contained in the <code class="code sidsref docutils literal notranslate"><span class="pre">GridConnectivity_t</span></code> structure, and overset-grid holes are identified in the <code class="code sidsref docutils literal notranslate"><span class="pre">OversetHoles_t</span></code> structure.</p>
<p>The <code class="code sidsref docutils literal notranslate"><span class="pre">UserDefinedData_t</span></code> data structure allows arbitrary user-defined data to be stored in <code class="code sidskey docutils literal notranslate"><span class="pre">Descriptor_t</span></code> and <code class="code sidskey docutils literal notranslate"><span class="pre">DataArray_t</span></code> children without the restrictions or implicit meanings imposed on these node types at other node locations.</p>
</div>
<div class="section" id="to-1-interface-connectivity-structure-definition-gridconnectivity1to1-t">
<h2><span class="section-number">8.2. </span>1-to-1 Interface Connectivity Structure Definition: <code class="docutils literal notranslate"><span class="pre">GridConnectivity1to1_t</span></code><a class="headerlink" href="#to-1-interface-connectivity-structure-definition-gridconnectivity1to1-t" title="Permalink to this headline">¶</a></h2>
<p><code class="code sidskey docutils literal notranslate"><span class="pre">GridConnectivity1to1_t</span></code> only applies to structured zones interfacing with structured donors and whose interface is a logically rectangular region.
It contains connectivity information for a multizone interface patch that is abutting with 1-to-1 matching between adjacent zone indices (also referred to as <span class="math notranslate nohighlight">\(C^{0}\)</span> connectivity).
An interface patch is the subrange of the face of a zone that touches one and only one other zone.
This structure identifies the subrange of indices for the two adjacent zones that make up the interface and gives an index transformation from one zone to the other.
It also identifies the name of the adjacent zone.</p>
<p>All the interface patches for a given zone are contained in the <code class="code sidskey docutils literal notranslate"><span class="pre">ZoneGridConnectivity_t</span></code> entity for that zone.
If a face of a zone touches several other zones (say <em>N</em>), then <em>N</em> different instances of the <code class="code sidskey docutils literal notranslate"><span class="pre">GridConnectivity1to1_t</span></code> structure must be included in the zone to describe each separate interface patch.
This convention requires that a single interface patch be described twice in the database - once for each adjacent zone.</p>
<div class="highlight-sids notranslate"><div class="highlight"><pre><span></span><span class="kt">GridConnectivity1to1_t</span><span class="o">&lt;</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">IndexDimension</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="o">:=</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">List</span><span class="p">(</span><span class="w"> </span><span class="kt">Descriptor_t</span><span class="w"> </span><span class="n">Descriptor1</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">DescriptorN</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w">                 </span><span class="kr">(o)</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="p">[</span><span class="n">IndexDimension</span><span class="p">]</span><span class="w"> </span><span class="n">Transform</span><span class="w"> </span><span class="p">;</span><span class="w">                                    </span><span class="kr">(o/d)</span><span class="w"></span>

<span class="w">  </span><span class="kt">IndexRange_t</span><span class="o">&lt;</span><span class="n">IndexDimension</span><span class="o">&gt;</span><span class="w"> </span><span class="n">PointRange</span><span class="w"> </span><span class="p">;</span><span class="w">                          </span><span class="kr">(r)</span><span class="w"></span>
<span class="w">  </span><span class="kt">IndexRange_t</span><span class="o">&lt;</span><span class="n">IndexDimension</span><span class="o">&gt;</span><span class="w"> </span><span class="n">PointRangeDonor</span><span class="w"> </span><span class="p">;</span><span class="w">                     </span><span class="kr">(r)</span><span class="w"></span>

<span class="w">  </span><span class="k">Identifier</span><span class="p">(</span><span class="kt">Zone_t</span><span class="p">)</span><span class="w"> </span><span class="n">ZoneDonorName</span><span class="w"> </span><span class="p">;</span><span class="w">                                 </span><span class="kr">(r)</span><span class="w"></span>

<span class="w">  </span><span class="kt">GridConnectivityProperty_t</span><span class="w"> </span><span class="n">GridConnectivityProperty</span><span class="w"> </span><span class="p">;</span><span class="w">              </span><span class="kr">(o)</span><span class="w"></span>

<span class="w">  </span><span class="k">List</span><span class="p">(</span><span class="w"> </span><span class="kt">UserDefinedData_t</span><span class="w"> </span><span class="n">UserDefinedData1</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">UserDefinedDataN</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w">  </span><span class="kr">(o)</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">Ordinal</span><span class="w"> </span><span class="p">;</span><span class="w">                                                      </span><span class="kr">(o)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ol class="arabic simple">
<li><p>Default names for the <code class="code sidskey docutils literal notranslate"><span class="pre">Descriptor_t</span></code> and <code class="code sidskey docutils literal notranslate"><span class="pre">UserDefinedData_t</span></code> lists are as shown; users may choose other legitimate names. Legitimate names must be unique within a given instance of <code class="code sidskey docutils literal notranslate"><span class="pre">GridConnectivity1to1_t</span></code> and shall not include the names <code class="code sidskey docutils literal notranslate"><span class="pre">GridConnectivityProperty</span></code>, <code class="code sidskey docutils literal notranslate"><span class="pre">PointRange</span></code>, <code class="code sidskey docutils literal notranslate"><span class="pre">PointRangeDonor</span></code>, <code class="code sidskey docutils literal notranslate"><span class="pre">Transform</span></code>, or <code class="code sidskey docutils literal notranslate"><span class="pre">Ordinal</span></code>.</p></li>
<li><p>If Transform is absent, then its default value is <code class="code docutils literal notranslate"><span class="pre">[+1,+2,+3]</span></code>.</p></li>
<li><p><code class="code sidskey docutils literal notranslate"><span class="pre">ZoneDonorName</span></code> must be equated to a 32 character maximum zone identifier within the current CGNS database (i.e., it must be equal to one of the <code class="code sidskey docutils literal notranslate"><span class="pre">Zone_t</span></code> identifiers contained in the current <code class="code sidskey docutils literal notranslate"><span class="pre">CGNSBase_t</span></code> entity) or to a 65 character maximum zone identifier in another base of the same CGNS tree; in that case the <code class="code sidskey docutils literal notranslate"><span class="pre">ZoneDonorName</span></code> string has the pattern base/zone, <strong>only one single “/” character is allowed</strong>, and neither basename nor zonename should be empty. <code class="code sidskey docutils literal notranslate"><span class="pre">ZoneDonorName</span></code> should also not be empty.</p></li>
<li><p>Beginning indices of <code class="code sidskey docutils literal notranslate"><span class="pre">PointRange</span></code> and <code class="code sidskey docutils literal notranslate"><span class="pre">PointRangeDonor</span></code> must coincide (i.e., must be the same physical point); ending indices of <code class="code sidskey docutils literal notranslate"><span class="pre">PointRange</span></code> and <code class="code sidskey docutils literal notranslate"><span class="pre">PointRangeDonor</span></code> must also coincide.</p></li>
<li><p>Elements of <code class="code sidskey docutils literal notranslate"><span class="pre">Transform</span></code> must be signed integers in the range <code class="code sidskey docutils literal notranslate"><span class="pre">-IndexDimension,</span> <span class="pre">...,</span> <span class="pre">+IndexDimension</span></code>; element magnitudes may not be repeated. In 3-D allowed elements are 0, ±1, ±2, ±3.</p></li>
</ol>
</div>
<p><code class="code sidskey docutils literal notranslate"><span class="pre">PointRange</span></code> contains the subrange of indices that makes up the interface patch in the current zone (i.e., that <code class="code sidskey docutils literal notranslate"><span class="pre">Zone_t</span></code> entity that contains the given instance of <code class="code sidskey docutils literal notranslate"><span class="pre">GridConnectivity1to1_t</span></code>).
<code class="code sidskey docutils literal notranslate"><span class="pre">PointRangeDonor</span></code> contains the interface patch subrange of indices for the adjacent zone (whose identifier is given by <code class="code sidskey docutils literal notranslate"><span class="pre">ZoneDonorName</span></code>).
By convention the indices contained in <code class="code sidskey docutils literal notranslate"><span class="pre">PointRange</span></code> and <code class="code sidskey docutils literal notranslate"><span class="pre">PointRangeDonor</span></code> refer to vertices.</p>
<p><code class="code sidskey docutils literal notranslate"><span class="pre">Transform</span></code> contains a short-hand notation for the transformation matrix describing the relation between indices of the two adjacent zones.
The transformation matrix itself has rank <code class="code sidskey docutils literal notranslate"><span class="pre">IndexDimension</span></code> and contains elements <span class="math notranslate nohighlight">\(+1\)</span>, <span class="math notranslate nohighlight">\(−1\)</span> and <span class="math notranslate nohighlight">\(0\)</span>; it is orthonormal and its inverse is its transpose.
The transformation matrix (<code class="code docutils literal notranslate"><span class="pre">T</span></code>) works as follows: If <code class="code docutils literal notranslate"><span class="pre">Index1</span></code> and <code class="code docutils literal notranslate"><span class="pre">Index2</span></code> are the indices of a given point on the interface, where <code class="code docutils literal notranslate"><span class="pre">Index1</span></code> is in the current zone and <code class="code docutils literal notranslate"><span class="pre">Index2</span></code> is in the adjacent zone, then their relationship is,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Index2</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="p">(</span><span class="n">Index1</span> <span class="o">-</span> <span class="n">Begin1</span><span class="p">)</span> <span class="o">+</span> <span class="n">Begin2</span>

<span class="n">Index1</span> <span class="o">=</span> <span class="n">Transpose</span><span class="p">[</span><span class="n">T</span><span class="p">]</span><span class="o">.</span><span class="p">(</span><span class="n">Index2</span> <span class="o">-</span> <span class="n">Begin2</span><span class="p">)</span> <span class="o">+</span> <span class="n">Begin1</span>
</pre></div>
</div>
<p>where the <code class="code docutils literal notranslate"><span class="pre">&quot;.&quot;</span></code> notation indicates matrix-vector multiply. <code class="code docutils literal notranslate"><span class="pre">Begin1</span></code> and <code class="code docutils literal notranslate"><span class="pre">End1</span></code> are the subrange indices contained in <code class="code sidskey docutils literal notranslate"><span class="pre">PointRange</span></code>, and <code class="code docutils literal notranslate"><span class="pre">Begin2</span></code> and <code class="code docutils literal notranslate"><span class="pre">End2</span></code> are the subrange indices contained in <code class="code sidskey docutils literal notranslate"><span class="pre">PointRangeDonor</span></code>.</p>
<p>The short-hand notation used in <code class="code sidskey docutils literal notranslate"><span class="pre">Transform</span></code> is as follows: Each element shows the image in the adjacent zone’s face of a positive index increment in the current zone’s face. The first element is the image of a positive increment in <em>i</em>; the second element is the image of an increment in <em>j</em>; and the third (in 3-D) is the image of an increment in <em>k</em> on the current zone’s face. For 3-D, the transformation matrix <code class="code docutils literal notranslate"><span class="pre">T</span></code> is constructed from <code class="code docutils literal notranslate"><span class="pre">Transform</span></code> <span class="math notranslate nohighlight">\(= [\pm a, \pm b, \pm c]\)</span> as follows:</p>
<div class="math notranslate nohighlight">
\[\begin{split}T  =
\begin{bmatrix}
sgn(a) del(a-1) &amp; sgn(b) del(b-1) &amp; sgn(c) del(c-1) \\
sgn(a) del(a-2) &amp; sgn(b) del(b-2) &amp; sgn(c) del(c-2) \\
sgn(a) del(a-3) &amp; sgn(b) del(b-3) &amp; sgn(c) del(c-3) \\
\end{bmatrix}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(sgn(x) \equiv +1 \text{ if } x ≥ 0\text{, and } -1 \text{ if } x &lt; 0\)</span>, and <span class="math notranslate nohighlight">\(del(x−y) \equiv +1 \text{ if } |x| = |y|\text{, and } 0 \text{ otherwise}\)</span>.</p>
<p>For example, <code class="code docutils literal notranslate"><span class="pre">Transform</span> <span class="pre">=</span> <span class="pre">[−2,</span> <span class="pre">+3,</span> <span class="pre">+1]</span></code> gives the transformation matrix,</p>
<div class="math notranslate nohighlight">
\[\begin{split}T  =
\begin{bmatrix}
0 &amp; 0 &amp; +1 \\
-1 &amp; 0 &amp; 0 \\
0 &amp; +1 &amp; 0 \\
\end{bmatrix}\end{split}\]</div>
<p>For establishing relationships between adjacent and current zone indices lying on the interface itself, one of the elements of <code class="code sidskey docutils literal notranslate"><span class="pre">Transform</span></code> is superfluous since one component of both interface indices remains constant.
It is therefore acceptable to set that element of <code class="code sidskey docutils literal notranslate"><span class="pre">Transform</span></code> to zero.</p>
<p>If the transformation matrix is used for continuation of computational coordinates into the adjacent zone (e.g., to find the location of a rind point in the adjacent zone), then all elements of <code class="code sidskey docutils literal notranslate"><span class="pre">Transform</span></code> are needed.
If the above mentioned superfluous element is set to zero, it can be easily regenerated from <code class="code sidskey docutils literal notranslate"><span class="pre">PointRange</span></code> and <code class="code sidskey docutils literal notranslate"><span class="pre">PointRangeDonor</span></code> and the grid sizes of the two zones.
This is done by determining the faces represented by <code class="code sidskey docutils literal notranslate"><span class="pre">PointRange</span></code> and <code class="code sidskey docutils literal notranslate"><span class="pre">PointRangeDonor</span></code> (i.e., <em>i</em>-min, <em>i</em>-max, <em>j</em>-min, etc.).
If one is a minimum face and the other a maximum face, then the sign of the missing element in <code class="code sidskey docutils literal notranslate"><span class="pre">Transform</span></code> is <code class="code docutils literal notranslate"><span class="pre">&quot;+&quot;</span></code>, and the value of the missing element in the transformation matrix (<code class="code docutils literal notranslate"><span class="pre">T</span></code>) is +1.
If the faces are both minimums or are both maximums, the sign is <code class="code docutils literal notranslate"><span class="pre">&quot;−&quot;</span></code>. Next, the position and magnitude of the element in <code class="code sidskey docutils literal notranslate"><span class="pre">Transform</span></code>, and hence the row and column in the transformation matrix, is given by the combinations of <em>i</em>, <em>j</em> and <em>k</em> faces for the two.
For example, if <code class="code sidskey docutils literal notranslate"><span class="pre">PointRange</span></code> represents a <em>j</em>-min or <em>j</em>-max face and <code class="code sidskey docutils literal notranslate"><span class="pre">PointRangeDonor</span></code> represents an <em>i</em>-min or <em>i</em>-max face, then the missing element’s position in <code class="code sidskey docutils literal notranslate"><span class="pre">Transform</span></code> is 2 and its magnitude is 1 (i.e., <span class="math notranslate nohighlight">\(\text{Transform } = [*, \pm 1, *]\)</span>).</p>
<p>Note also that the transform matrix and the two index pairs overspecify the interface patch.
For example, <code class="code docutils literal notranslate"><span class="pre">End2</span></code> can be obtained from <code class="code docutils literal notranslate"><span class="pre">Transform</span></code>, <code class="code docutils literal notranslate"><span class="pre">Begin1</span></code>, <code class="code docutils literal notranslate"><span class="pre">End1</span></code> and <code class="code docutils literal notranslate"><span class="pre">Begin2</span></code>.</p>
<p>A <code class="code sidsref docutils literal notranslate"><span class="pre">GridConnectivityProperty_t</span></code> data structure may be used to record special properties associated with particular connectivity patches, such as a periodic interface, or an interface where data is to be averaged in some way.</p>
<p>The <code class="code sidsref docutils literal notranslate"><span class="pre">UserDefinedData_t</span></code> data structure allows arbitrary user-defined data to be stored in <code class="code sidskey docutils literal notranslate"><span class="pre">Descriptor_t</span></code> and <code class="code sidskey docutils literal notranslate"><span class="pre">DataArray_t</span></code> children without the restrictions or implicit meanings imposed on these node types at other node locations.</p>
<p><code class="code sidskey docutils literal notranslate"><span class="pre">Ordinal</span></code> is user-defined and has no restrictions on the values that it can contain. It is included for backward compatibility to assist implementation of the CGNS system into applications whose I/O depends heavily on the numbering of zone interfaces.
Since there are no restrictions on the values contained in <code class="code sidskey docutils literal notranslate"><span class="pre">Ordinal</span></code> (or that <code class="code sidskey docutils literal notranslate"><span class="pre">Ordinal</span></code> is even provided), there is no guarantee that the interfaces in an existing CGNS database will have sequential values from 1 to N without holes or repetitions. Use of <code class="code sidskey docutils literal notranslate"><span class="pre">Ordinal</span></code> is discouraged and is on a user-beware basis.</p>
</div>
<div class="section" id="to-1-interface-connectivity-examples">
<h2><span class="section-number">8.3. </span>1-to-1 Interface Connectivity Examples<a class="headerlink" href="#to-1-interface-connectivity-examples" title="Permalink to this headline">¶</a></h2>
<p>This section contains two examples of structure entities for describing the connectivity for structured-zone 1-to-1 abutting multizone interfaces. The Structured Two-Zone Flat Plate Example contains additional examples of 1-to-1 interfaces.</p>
<div class="section" id="example-1-to-1-abutting-of-complete-faces">
<h3><span class="section-number">8.3.1. </span>Example - 1-to-1 Abutting of Complete Faces<a class="headerlink" href="#example-1-to-1-abutting-of-complete-faces" title="Permalink to this headline">¶</a></h3>
<p>Two zones have the same orientation; zone 1 is <span class="math notranslate nohighlight">\(9 \times 17 \times 11\)</span> and zone 2 is <span class="math notranslate nohighlight">\(9 \times 17 \times 21\)</span>.
The <em>k</em>-max face of zone 1 abuts the <em>k</em>-min face of zone 2. Contained in the structure entities of zone 1 is the following interface structure:</p>
<div class="highlight-sids notranslate"><div class="highlight"><pre><span></span><span class="kt">GridConnectivity1to1_t</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Zone1</span><span class="o">/</span><span class="n">ZoneGridConnectivity</span><span class="o">/</span><span class="n">KMax</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">  </span><span class="p">{{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="n">Transform</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">IndexRange_t</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">PointRange</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="p">{{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="n">Begin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">11</span><span class="p">]</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="n">End</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">11</span><span class="p">]</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">IndexRange_t</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">PointRangeDonor</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="p">{{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="n">Begin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="n">End</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">Identifier</span><span class="p">(</span><span class="kt">Zone_t</span><span class="p">)</span><span class="w"> </span><span class="n">ZoneDonorName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Zone2</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>Contained in the structure entities of zone 2 is the following:</p>
<div class="highlight-sids notranslate"><div class="highlight"><pre><span></span><span class="kt">GridConnectivity1to1_t</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Zone2</span><span class="o">/</span><span class="n">ZoneGridConnectivity</span><span class="o">/</span><span class="n">KMin</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">  </span><span class="p">{{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="n">Transform</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">IndexRange_t</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">PointRange</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="p">{{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="n">Begin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="n">End</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">IndexRange_t</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">PointRangeDonor</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="p">{{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="n">Begin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">11</span><span class="p">]</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="n">End</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">11</span><span class="p">]</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">Identifier</span><span class="p">(</span><span class="kt">Zone_t</span><span class="p">)</span><span class="w"> </span><span class="n">ZoneDonorName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Zone1</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>This example assumes zones 1 and 2 have the identifiers <code class="code docutils literal notranslate"><span class="pre">Zone1</span></code> and <code class="code docutils literal notranslate"><span class="pre">Zone2</span></code>, respectively.</p>
</div>
<div class="section" id="example-1-to-1-abutting-complete-face-to-a-subset-of-a-face">
<h3><span class="section-number">8.3.2. </span>Example - 1-to-1 Abutting, Complete Face to a Subset of a Face<a class="headerlink" href="#example-1-to-1-abutting-complete-face-to-a-subset-of-a-face" title="Permalink to this headline">¶</a></h3>
<div class="figure align-center" id="id1">
<a class="reference internal image-reference" href="../../_images/cnct_1to1.gif"><img alt="Two abutting zones, with 1-to-1 abutting of a complete face to a subset of a face" src="../../_images/cnct_1to1.gif" style="width: 600px;" /></a>
<p class="caption"><span class="caption-text"><em>Example Interface for 1-to-1 Connectivity</em></span><a class="headerlink" href="#id1" title="Permalink to this image">¶</a></p>
</div>
<p>The above figure shows a more complex 1-to-1 abutting interface, where the entire <em>j</em>-max face of zone 2 coincides with a subset of the <em>i</em>-max face of zone 1.
This situation would result in the following connectivity structures:</p>
<div class="highlight-sids notranslate"><div class="highlight"><pre><span></span><span class="kt">GridConnectivity1to1_t</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Zone1</span><span class="o">/</span><span class="n">ZoneGridConnectivity</span><span class="o">/</span><span class="n">IMax</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">  </span><span class="p">{{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="n">Transform</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">-2</span><span class="p">,</span><span class="mi">-1</span><span class="p">,</span><span class="mi">-3</span><span class="p">]</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">IndexRange_t</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">PointRange</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="p">{{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="n">Begin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">17</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="n">End</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">17</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">IndexRange_t</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">PointRangeDonor</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="p">{{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="n">Begin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="n">End</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">Identifier</span><span class="p">(</span><span class="kt">Zone_t</span><span class="p">)</span><span class="w"> </span><span class="n">ZoneDonorName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Zone2</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>

<span class="kt">GridConnectivity1to1_t</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Zone2</span><span class="o">/</span><span class="n">ZoneGridConnectivity</span><span class="o">/</span><span class="n">JMax</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">  </span><span class="p">{{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="n">Transform</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">-2</span><span class="p">,</span><span class="mi">-1</span><span class="p">,</span><span class="mi">-3</span><span class="p">]</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">IndexRange_t</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">PointRange</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="p">{{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="n">Begin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="n">End</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">IndexRange_t</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">PointRangeDonor</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="p">{{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="n">Begin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">17</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="n">End</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">17</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">Identifier</span><span class="p">(</span><span class="kt">Zone_t</span><span class="p">)</span><span class="w"> </span><span class="n">ZoneDonorName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Zone1</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>This example also assumes zones 1 and 2 have the identifiers <code class="code docutils literal notranslate"><span class="pre">Zone1</span></code> and <code class="code docutils literal notranslate"><span class="pre">Zone2</span></code>, respectively.
Note that the index transformation matrix for both this and the previous examples is symmetric; hence, the value of <code class="code sidskey docutils literal notranslate"><span class="pre">Transform</span></code> is identical for both members of the interface pair.
In general this will not always be the case.</p>
</div>
</div>
<div class="section" id="general-interface-connectivity-structure-definition-gridconnectivity-t">
<h2><span class="section-number">8.4. </span>General Interface Connectivity Structure Definition: <code class="docutils literal notranslate"><span class="pre">GridConnectivity_t</span></code><a class="headerlink" href="#general-interface-connectivity-structure-definition-gridconnectivity-t" title="Permalink to this headline">¶</a></h2>
<p><code class="code sidskey docutils literal notranslate"><span class="pre">GridConnectivity_t</span></code> contains connectivity information for generalized multizone interfaces, and may be used for any mix of structured and unstructured zones. Its purpose is to describe mismatched-abutting and overset interfaces, but can also be used for 1-to-1 abutting interfaces.</p>
<p>For abutting interfaces that are not 1-to-1, also referred to as patched or mismatched, an interface patch is the subrange of the face of a zone that touches one and only one other zone.
This structure identifies the subrange of indices (or array of indices) that make up the interface and gives their image in the adjacent (donor) zone.
It also identifies the name of the adjacent zone. If a given face of a zone touches several (say <em>N</em>) adjacent zones, then <em>N</em> different instances of <code class="code sidskey docutils literal notranslate"><span class="pre">GridConnectivity_t</span></code> are needed to describe all the interfaces.
For a single abutting interface, two instances of <code class="code sidskey docutils literal notranslate"><span class="pre">GridConnectivity_t</span></code> are needed in the database - one for each adjacent zone.</p>
<p>For overset interfaces, this structure identifies the fringe points of a given zone that lie in one and only one other zone.
If the fringe points of a zone lie in several (say <em>N</em>) overlapping zones, then <em>N</em> different instances of <code class="code sidskey docutils literal notranslate"><span class="pre">GridConnectivity_t</span></code> are needed to describe the overlaps.
It is possible with overset grids that a single fringe point may actually lie in several overlapping zones (though in typical usage, linkage to only one of the overlapping zones is kept).
There is no restriction against a given fringe point being contained within multiple instances of <code class="code sidskey docutils literal notranslate"><span class="pre">GridConnectivity_t</span></code>; therefore, this structure allows the description of a single fringe point lying in several overlapping zones.</p>
<div class="highlight-sids notranslate"><div class="highlight"><pre><span></span><span class="kt">GridConnectivityType_t</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">Enumeration</span><span class="p">(</span><span class="w"></span>
<span class="w">  </span><span class="n">GridConnectivityTypeNull</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">GridConnectivityTypeUserDefined</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">Overset</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">Abutting</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">Abutting1to1</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w"></span>

<span class="kt">GridConnectivity_t</span><span class="o">&lt;</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">IndexDimension</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">CellDimension</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="o">:=</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">List</span><span class="p">(</span><span class="w"> </span><span class="kt">Descriptor_t</span><span class="w"> </span><span class="n">Descriptor1</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">DescriptorN</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w">                 </span><span class="kr">(o)</span><span class="w"></span>

<span class="w">  </span><span class="kt">GridConnectivityType_t</span><span class="w"> </span><span class="n">GridConnectivityType</span><span class="w"> </span><span class="p">;</span><span class="w">                      </span><span class="kr">(o/d)</span><span class="w"></span>

<span class="w">  </span><span class="kt">GridLocation_t</span><span class="w"> </span><span class="n">GridLocation</span><span class="w"> </span><span class="p">;</span><span class="w">                                      </span><span class="kr">(o/d)</span><span class="w"></span>

<span class="w">  </span><span class="kt">IndexRange_t</span><span class="o">&lt;</span><span class="n">IndexDimension</span><span class="o">&gt;</span><span class="w"> </span><span class="n">PointRange</span><span class="w"> </span><span class="p">;</span><span class="w">                          </span><span class="kr">(o:r)</span><span class="w"></span>
<span class="w">  </span><span class="kt">IndexArray_t</span><span class="o">&lt;</span><span class="n">IndexDimension</span><span class="p">,</span><span class="w"> </span><span class="n">PointListSize</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w">  </span><span class="n">PointList</span><span class="w"> </span><span class="p">;</span><span class="w">      </span><span class="kr">(r:o)</span><span class="w"></span>
<span class="w">  </span><span class="kt">IndexArray_t</span><span class="o">&lt;</span><span class="n">IndexDimension</span><span class="p">,</span><span class="w"> </span><span class="n">PointListSize</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w">  </span><span class="n">PointListDonor</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="kr">(o)</span><span class="w"></span>
<span class="w">  </span><span class="kt">IndexArray_t</span><span class="o">&lt;</span><span class="n">IndexDimension</span><span class="p">,</span><span class="w"> </span><span class="n">PointListSize</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w">  </span><span class="n">CellListDonor</span><span class="w"> </span><span class="p">;</span><span class="w">  </span><span class="kr">(o)</span><span class="w"></span>

<span class="w">  </span><span class="k">Identifier</span><span class="p">(</span><span class="kt">Zone_t</span><span class="p">)</span><span class="w"> </span><span class="n">ZoneDonorName</span><span class="w"> </span><span class="p">;</span><span class="w">                                 </span><span class="kr">(r)</span><span class="w"></span>

<span class="w">  </span><span class="kt">DataArray_t</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">real</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">CellDimension</span><span class="p">,</span><span class="w"> </span><span class="n">PointListSize</span><span class="p">]</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">     </span><span class="n">InterpolantsDonor</span><span class="w">                                               </span><span class="kr">(o)</span><span class="w"></span>

<span class="w">  </span><span class="kt">GridConnectivityProperty_t</span><span class="w"> </span><span class="n">GridConnectivityProperty</span><span class="w"> </span><span class="p">;</span><span class="w">              </span><span class="kr">(o)</span><span class="w"></span>

<span class="w">  </span><span class="k">List</span><span class="p">(</span><span class="w"> </span><span class="kt">UserDefinedData_t</span><span class="w"> </span><span class="n">UserDefinedData1</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">UserDefinedDataN</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w">  </span><span class="kr">(o)</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">Ordinal</span><span class="w"> </span><span class="p">;</span><span class="w">                                                      </span><span class="kr">(o)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ol class="arabic simple">
<li><p>Default names for the <code class="code sidskey docutils literal notranslate"><span class="pre">Descriptor_t</span></code> and <code class="code sidskey docutils literal notranslate"><span class="pre">UserDefinedData_t</span></code> lists are as shown; users may choose other legitimate names. Legitimate names must be unique within a given instance of <code class="code sidskey docutils literal notranslate"><span class="pre">GridConnectivity_t</span></code> and shall not include the names <code class="code sidskey docutils literal notranslate"><span class="pre">CellListDonor</span></code>, <code class="code sidskey docutils literal notranslate"><span class="pre">GridConnectivityProperty</span></code>, <code class="code sidskey docutils literal notranslate"><span class="pre">GridConnectivityType</span></code>, <code class="code sidskey docutils literal notranslate"><span class="pre">GridLocation</span></code>, <code class="code sidskey docutils literal notranslate"><span class="pre">InterpolantsDonor</span></code>, <code class="code sidskey docutils literal notranslate"><span class="pre">Ordinal</span></code>, <code class="code sidskey docutils literal notranslate"><span class="pre">PointList</span></code>, <code class="code sidskey docutils literal notranslate"><span class="pre">PointListDonor</span></code>, or <code class="code sidskey docutils literal notranslate"><span class="pre">PointRange</span></code>.</p></li>
<li><p><code class="code sidskey docutils literal notranslate"><span class="pre">ZoneDonorName</span></code> must be equated to a 32 character maximum zone identifier within the current CGNS database (i.e., it must be equal to one of the <code class="code sidskey docutils literal notranslate"><span class="pre">Zone_t</span></code> identifiers contained in the current <code class="code sidskey docutils literal notranslate"><span class="pre">CGNSBase_t</span></code> entity) or to a 65 character maximum zone identifier in another base of the same CGNS tree; in that case the <code class="code sidskey docutils literal notranslate"><span class="pre">ZoneDonorName</span></code> string has the pattern <em>base/zone</em>, only one single “/” character is allowed, and neither basename nor zonename should be empty. <code class="code sidskey docutils literal notranslate"><span class="pre">ZoneDonorName</span></code> should also not be empty.</p></li>
<li><p>If <code class="code sidskey docutils literal notranslate"><span class="pre">GridConnectivityType</span></code> is absent, then its default value is <code class="code sidskey docutils literal notranslate"><span class="pre">Overset</span></code>.</p></li>
<li><p>For <code class="code sidskey docutils literal notranslate"><span class="pre">Abutting</span></code> or <code class="code sidskey docutils literal notranslate"><span class="pre">Abutting1to1</span></code> interfaces, <code class="code sidskey docutils literal notranslate"><span class="pre">GridLocation</span></code> can be either <code class="code sidskey docutils literal notranslate"><span class="pre">Vertex</span></code> or <code class="code sidskey docutils literal notranslate"><span class="pre">FaceCenter</span></code>. When <code class="code sidskey docutils literal notranslate"><span class="pre">GridLocation</span></code> is set to <code class="code sidskey docutils literal notranslate"><span class="pre">Vertex</span></code>, then <code class="code sidskey docutils literal notranslate"><span class="pre">PointList</span></code> or <code class="code sidskey docutils literal notranslate"><span class="pre">PointRange</span></code> refer to node indices, for both structured and unstructured grids. When <code class="code sidskey docutils literal notranslate"><span class="pre">GridLocation</span></code> is set to <code class="code sidskey docutils literal notranslate"><span class="pre">FaceCenter</span></code>, then <code class="code sidskey docutils literal notranslate"><span class="pre">PointList</span></code> or <code class="code sidskey docutils literal notranslate"><span class="pre">PointRange</span></code> refer to face elements. Face elements are indexed using different methods depending if the zone is structured or unstructured. For a structured zone, face elements are indexed using the minimum of the connecting vertex indices, as described in the section <a class="reference internal" href="convention.html#structgrid"><span class="std std-ref">Structured Grid Notation and Indexing Conventions</span></a>. For an unstructured zone, face elements are indexed using their element numbering, as defined in the <code class="code sidskey docutils literal notranslate"><span class="pre">Elements_t</span></code> data structures. For <code class="code sidskey docutils literal notranslate"><span class="pre">Overset</span></code> interfaces, <code class="code sidskey docutils literal notranslate"><span class="pre">GridLocation</span></code> can be either <code class="code sidskey docutils literal notranslate"><span class="pre">Vertex</span></code> or <code class="code sidskey docutils literal notranslate"><span class="pre">CellCenter</span></code>, allowing the description of the overlap region in the receiver zone to be consistent with the grid location used for storing the flow solution. If <code class="code sidskey docutils literal notranslate"><span class="pre">GridLocation</span></code> is absent, then its default value is <code class="code sidskey docutils literal notranslate"><span class="pre">Vertex</span></code>.</p></li>
<li><p>One of <code class="code sidskey docutils literal notranslate"><span class="pre">PointRange</span></code> and <code class="code sidskey docutils literal notranslate"><span class="pre">PointList</span></code> must be specified, but not both.</p></li>
<li><p>If <code class="code sidskey docutils literal notranslate"><span class="pre">PointRange</span></code> is specified, then an index ordering convention is needed to map receiver-zone grid points to donor-zone grid points. FORTRAN multidimensional array ordering is used.</p></li>
<li><p>If <code class="code sidskey docutils literal notranslate"><span class="pre">GridConnectivityType</span></code> is <code class="code sidskey docutils literal notranslate"><span class="pre">Abutting1to1</span></code> or <code class="code sidskey docutils literal notranslate"><span class="pre">Abutting</span></code>, then <code class="code sidskey docutils literal notranslate"><span class="pre">PointRange</span></code> or <code class="code sidskey docutils literal notranslate"><span class="pre">PointList</span></code> must define points associated with a face subrange (if the zone is structured, all points must be in a single computational grid plane); the donor-zone grid locations defined by <code class="code sidskey docutils literal notranslate"><span class="pre">PointListDonor</span></code> or <code class="code sidskey docutils literal notranslate"><span class="pre">CellListDonor</span></code> must also be associated with a face subrange.</p></li>
<li><p>If donor information is given, either <code class="code sidskey docutils literal notranslate"><span class="pre">PointListDonor</span></code> alone, or <code class="code sidskey docutils literal notranslate"><span class="pre">CellListDonor</span></code> with or without <code class="code sidskey docutils literal notranslate"><span class="pre">InterpolantsDonor</span></code>, must be used. The use of <code class="code sidskey docutils literal notranslate"><span class="pre">PointListDonor</span></code> is restricted to <code class="code sidskey docutils literal notranslate"><span class="pre">Abutting1to1</span></code>, whereas <code class="code sidskey docutils literal notranslate"><span class="pre">CellListDonor</span></code> can be used for any interface type.</p></li>
<li><p>Thus, for a <code class="code sidskey docutils literal notranslate"><span class="pre">GridConnectivityType</span></code> that is not <code class="code sidskey docutils literal notranslate"><span class="pre">Abutting1to1</span></code>, there are three allowable levels of description concerning the connectivity information: (a) full, giving <code class="code sidskey docutils literal notranslate"><span class="pre">ZoneDonorName</span></code> with <code class="code sidskey docutils literal notranslate"><span class="pre">CellListDonor</span></code> plus <code class="code sidskey docutils literal notranslate"><span class="pre">InterpolantsDonor</span></code>; (b) partial, giving <code class="code sidskey docutils literal notranslate"><span class="pre">ZoneDonorName</span></code> with <code class="code sidskey docutils literal notranslate"><span class="pre">CellListDonor</span></code> but no <code class="code sidskey docutils literal notranslate"><span class="pre">InterpolantsDonor</span></code>; or (c) minimal, giving <code class="code sidskey docutils literal notranslate"><span class="pre">ZoneDonorName</span></code> only.</p></li>
</ol>
</div>
<p>The type of multizone interface connectivity may be <code class="code sidskey docutils literal notranslate"><span class="pre">Overset</span></code>, <code class="code sidskey docutils literal notranslate"><span class="pre">Abutting</span></code>, or <code class="code sidskey docutils literal notranslate"><span class="pre">Abutting1to1</span></code>. <code class="code sidskey docutils literal notranslate"><span class="pre">Overset</span></code> refers to zones that overlap; for a 3-D configuration the overlap is a 3-D region. <code class="code sidskey docutils literal notranslate"><span class="pre">Abutting</span></code> refers to zones that abut or touch, but do not overlap (other than the vertices and faces that make up the interface).
<code class="code sidskey docutils literal notranslate"><span class="pre">Abutting1to1</span></code> is a special case of abutting interfaces where grid lines are continuous across the interface and all vertices on the interface are shared by the two adjacent zones.</p>
<p>The interface grid points within the receiver zone may be specified by <code class="code sidskey docutils literal notranslate"><span class="pre">PointRange</span></code> if they constitute a logically rectangular region (e.g., an abutting interface where an entire face of the receiver zone abuts with a part of a face of the donor zone).
In all other cases, <code class="code sidskey docutils literal notranslate"><span class="pre">PointList</span></code> should be used to list the receiver-zone grid points making up the interface.
For a structured-to-structured interface, all indices in <code class="code sidskey docutils literal notranslate"><span class="pre">PointRange</span></code> or <code class="code sidskey docutils literal notranslate"><span class="pre">PointList</span></code> should have one index element in common (see note 7).</p>
<p><code class="code sidsref docutils literal notranslate"><span class="pre">GridLocation</span></code> identifies the location of indices within the receiver zone described by <code class="code sidskey docutils literal notranslate"><span class="pre">PointRange</span></code> or <code class="code sidskey docutils literal notranslate"><span class="pre">PointList</span></code>.
It also identifies the location of indices defined by <code class="code sidskey docutils literal notranslate"><span class="pre">PointListDonor</span></code> in the donor zone. <code class="code sidskey docutils literal notranslate"><span class="pre">GridLocation</span></code> does not apply to <code class="code sidskey docutils literal notranslate"><span class="pre">CellListDonor</span></code> or <code class="code sidskey docutils literal notranslate"><span class="pre">InterpolantsDonor</span></code>.
The <code class="code sidskey docutils literal notranslate"><span class="pre">CellListDonor</span></code> is always an index or indices that define a particular cell or element, while the <code class="code sidskey docutils literal notranslate"><span class="pre">InterpolantsDonor</span></code> defines an interpolation value relative to the cell/element vertices.
In other words, when using <code class="code sidskey docutils literal notranslate"><span class="pre">InterpolantsDonor</span></code>, the interpolants are always given with respect to the vertices of the donor zone.
<code class="code sidskey docutils literal notranslate"><span class="pre">InterpolantsDonor</span></code> is currently only defined for structured grids and certain basic unstructured grid element types.</p>
<p>For structured grids, the interpolant value is given along each index direction, depending on the location within the cell.
For example, if the point is located within the cell at a position 75% in the <em>i</em>-direction, 41% in the <em>j</em>-direction, and 20% in the <em>k</em>-direction, then <code class="code sidskey docutils literal notranslate"><span class="pre">InterpolantsDonor</span></code> values <span class="math notranslate nohighlight">\((r, s, t)\)</span> would be <code class="code docutils literal notranslate"><span class="pre">(0.75,</span> <span class="pre">0.41,</span> <span class="pre">0.20)</span></code>.</p>
<p>The interpolation function is a linear combination of the <em>x</em>, <em>y</em>, and <em>z</em> values at the surrounding nodes:</p>
<div class="math notranslate nohighlight">
\[d = \sum_{i=1}^{N} W_{i} \cdot d_{i}\]</div>
<p>where <span class="math notranslate nohighlight">\(d\)</span> is the <span class="math notranslate nohighlight">\(x\)</span>, <span class="math notranslate nohighlight">\(y\)</span>, or <span class="math notranslate nohighlight">\(z\)</span> value at an interior point in the cell, <span class="math notranslate nohighlight">\(d_{i}\)</span> is the <span class="math notranslate nohighlight">\(x\)</span>, <span class="math notranslate nohighlight">\(y\)</span>, or <span class="math notranslate nohighlight">\(z\)</span> value at node <em>i</em>, and <span class="math notranslate nohighlight">\(W_{i}\)</span> is a weight at node <em>i</em>.
The weights are functions of the parametric variables <span class="math notranslate nohighlight">\(r\)</span>, <span class="math notranslate nohighlight">\(s\)</span>, and <span class="math notranslate nohighlight">\(t\)</span> (corresponding with the <em>i</em>, <em>j</em>, and <em>k</em> directions, respectively), which vary from 0 to 1, inclusively.
For structured grids in 3-D, <span class="math notranslate nohighlight">\(N = 8\)</span>. Note that for skewed, non-parallel grids, it is not always easy to determine the interpolants geometrically, and it may be necessary to solve an inverse problem using the interpolation function.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><div class="figure align-center">
<a class="reference internal image-reference" href="../../_images/cnct_struct.gif"><img alt="Structured grid cell" src="../../_images/cnct_struct.gif" style="width: 300px;" /></a>
</div>
</td>
<td><div class="math notranslate nohighlight">
\[\begin{split}W_{i,j,k} &amp;= (1 − r) (1 − s) (1 − t) \\
W_{i+1,j,k} &amp;= r (1 − s) (1 − t) \\
W_{i,j+1,k} &amp;= (1 − r) s (1 − t) \\
W_{i,j,k+1} &amp;= (1 − r)(1 − s) t \\
W_{i+1,j+1,k} &amp;= r s (1 − t) \\
W_{i+1,j,k+1} &amp;= r (1 − s) t \\
W_{i,j+1,k+1} &amp;= (1 − r) s t \\
W_{i+1,j+1,k+1} &amp;= r s t\end{split}\]</div>
</td>
</tr>
</tbody>
</table>
<p>For unstructured grids, <code class="code sidskey docutils literal notranslate"><span class="pre">InterpolantsDonor</span></code> is defined only for the basic linear element types: <code class="code sidskey docutils literal notranslate"><span class="pre">BAR_2</span></code>, <code class="code sidskey docutils literal notranslate"><span class="pre">TRI_3</span></code>, <code class="code sidskey docutils literal notranslate"><span class="pre">QUAD_4</span></code>, <code class="code sidskey docutils literal notranslate"><span class="pre">TETRA_4</span></code>, <code class="code sidskey docutils literal notranslate"><span class="pre">PYRA_5</span></code>, <code class="code sidskey docutils literal notranslate"><span class="pre">PENTA_6</span></code>, and <code class="code sidskey docutils literal notranslate"><span class="pre">HEXA_8</span></code>.
The directionality for the <span class="math notranslate nohighlight">\(r\)</span>, <span class="math notranslate nohighlight">\(s\)</span>, and <span class="math notranslate nohighlight">\(t\)</span> interpolants for the basic element types is defined as follows.</p>
<table class="docutils align-default" id="id2">
<caption><span class="caption-text"><code class="docutils literal notranslate"><span class="pre">BAR_2</span></code></span><a class="headerlink" href="#id2" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><div class="figure align-center">
<a class="reference internal image-reference" href="../../_images/cnct_unst_bar2.gif"><img alt="Unstructured grid line element" src="../../_images/cnct_unst_bar2.gif" style="width: 260px;" /></a>
</div>
</td>
<td><div class="math notranslate nohighlight">
\[\begin{split}W_{1} &amp;= 1 − r \\
W_{2} &amp;= r\end{split}\]</div>
</td>
</tr>
</tbody>
</table>
<table class="docutils align-default" id="id3">
<caption><span class="caption-text"><code class="docutils literal notranslate"><span class="pre">TRI_3</span></code></span><a class="headerlink" href="#id3" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><div class="figure align-center">
<a class="reference internal image-reference" href="../../_images/cnct_unst_tri3.gif"><img alt="Unstructured grid triangular element" src="../../_images/cnct_unst_tri3.gif" style="width: 260px;" /></a>
</div>
</td>
<td><div class="math notranslate nohighlight">
\[\begin{split}W_{1} &amp;= 1 − r - s \\
W_{2} &amp;= r \\
W_{3} &amp;= s\end{split}\]</div>
</td>
</tr>
</tbody>
</table>
<table class="docutils align-default" id="id4">
<caption><span class="caption-text"><code class="docutils literal notranslate"><span class="pre">QUAD_4</span></code></span><a class="headerlink" href="#id4" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><div class="figure align-center">
<a class="reference internal image-reference" href="../../_images/cnct_unst_quad4.gif"><img alt="Unstructured grid quadrilateral element" src="../../_images/cnct_unst_quad4.gif" style="width: 260px;" /></a>
</div>
</td>
<td><div class="math notranslate nohighlight">
\[\begin{split}W_{1} &amp;= (1 − r) (1 - s) \\
W_{2} &amp;= r (1 - s)\\
W_{3} &amp;= r s \\
W_{4} &amp;= (1 - r) s\end{split}\]</div>
</td>
</tr>
</tbody>
</table>
<table class="docutils align-default" id="id5">
<caption><span class="caption-text"><code class="docutils literal notranslate"><span class="pre">TETRA_4</span></code></span><a class="headerlink" href="#id5" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><div class="figure align-center">
<a class="reference internal image-reference" href="../../_images/cnct_unst_tetra4.gif"><img alt="Unstructured grid tetrahedral element" src="../../_images/cnct_unst_tetra4.gif" style="width: 260px;" /></a>
</div>
</td>
<td><div class="math notranslate nohighlight">
\[\begin{split}W_{1} &amp;= 1 − r - s - t \\
W_{2} &amp;= r \\
W_{3} &amp;= s \\
W_{4} &amp;= t\end{split}\]</div>
</td>
</tr>
</tbody>
</table>
<table class="docutils align-default" id="id6">
<caption><span class="caption-text"><code class="docutils literal notranslate"><span class="pre">PYRA_5</span></code></span><a class="headerlink" href="#id6" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><div class="figure align-center">
<a class="reference internal image-reference" href="../../_images/cnct_unst_pyra5.gif"><img alt="Unstructured grid pyramid element" src="../../_images/cnct_unst_pyra5.gif" style="width: 260px;" /></a>
</div>
</td>
<td><div class="math notranslate nohighlight">
\[\begin{split}W_{1} &amp;= (1 − r)(1 - s)(1 - t) \\
W_{2} &amp;= r (1 - s)(1 - t)\\
W_{3} &amp;= r s (1 - t) \\
W_{4} &amp;= (1 - r) s (1 - t) \\
W_{5} &amp;= t\end{split}\]</div>
</td>
</tr>
</tbody>
</table>
<table class="docutils align-default" id="id7">
<caption><span class="caption-text"><code class="docutils literal notranslate"><span class="pre">PENTA_6</span></code></span><a class="headerlink" href="#id7" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><div class="figure align-center">
<a class="reference internal image-reference" href="../../_images/cnct_unst_penta6.gif"><img alt="Unstructured grid pentahedral element" src="../../_images/cnct_unst_penta6.gif" style="width: 260px;" /></a>
</div>
</td>
<td><div class="math notranslate nohighlight">
\[\begin{split}W_{1} &amp;= (1 − r − s)(1 − t) \\
W_{2} &amp;= r (1 - s)\\
W_{3} &amp;= s (1 - t) \\
W_{4} &amp;= (1 - r - s) t \\
W_{5} &amp;= r t \\
W_{6} &amp;= s t\end{split}\]</div>
</td>
</tr>
</tbody>
</table>
<table class="docutils align-default" id="id8">
<caption><span class="caption-text"><code class="docutils literal notranslate"><span class="pre">HEXA_8</span></code></span><a class="headerlink" href="#id8" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><div class="figure align-center">
<a class="reference internal image-reference" href="../../_images/cnct_unst_hexa8.gif"><img alt="Unstructured grid hexahedral element" src="../../_images/cnct_unst_hexa8.gif" style="width: 280px;" /></a>
</div>
</td>
<td><div class="math notranslate nohighlight">
\[\begin{split}W_{1} &amp;= (1 − r)(1 − s)(1 − t) \\
W_{2} &amp;= r (1 − s)(1 − t)\\
W_{3} &amp;= r s (1 − t) \\
W_{4} &amp;= (1 − r) s (1 − t) \\
W_{5} &amp;= (1 − r) (1 − s) t \\
W_{6} &amp;= r (1 − s) t \\
W_{7} &amp;= r s t \\
W_{8} &amp;= (1 − r) s t\end{split}\]</div>
</td>
</tr>
</tbody>
</table>
<p><code class="code sidskey docutils literal notranslate"><span class="pre">PointListDonor</span></code> may only be used when the interface is <code class="code sidskey docutils literal notranslate"><span class="pre">Abutting1to1</span></code>.
It contains the images of all the receiver-zone interface points in the donor zone. If the zone is structured, all indices in <code class="code sidskey docutils literal notranslate"><span class="pre">PointListDonor</span></code> should have one index element in common.</p>
<p>For mismatched or overset interfaces, the zone connectivity donor information, when given, is defined using either the <code class="code sidskey docutils literal notranslate"><span class="pre">CellListDonor</span></code> alone, or the combination of <code class="code sidskey docutils literal notranslate"><span class="pre">CellListDonor</span></code> and <code class="code sidskey docutils literal notranslate"><span class="pre">InterpolantsDonor</span></code>.
<code class="code sidskey docutils literal notranslate"><span class="pre">CellListDonor</span></code> contains the list of donor cells or elements in which each node of the receiver zone can be located.
<code class="code sidskey docutils literal notranslate"><span class="pre">InterpolantsDonor</span></code> contains the interpolation factors to locate the receiver nodes in the donor cells.
<code class="code sidskey docutils literal notranslate"><span class="pre">InterpolantsDonor</span></code> may be thought of as bi- or tri-linear interpolants (depending on <code class="code sidskey docutils literal notranslate"><span class="pre">CellDimension</span></code>) in the cell of the donor zone.</p>
<p>A <code class="code sidskey docutils literal notranslate"><span class="pre">GridConnectivityProperty_t</span></code> data structure may be used to record special properties associated with particular connectivity patches, such as a periodic interface, or an interface where data is to be averaged in some way.</p>
<p>The <code class="code sidskey docutils literal notranslate"><span class="pre">UserDefinedData_t</span></code> data structure allows arbitrary user-defined data to be stored in <code class="code sidskey docutils literal notranslate"><span class="pre">Descriptor_t</span></code> and <code class="code sidskey docutils literal notranslate"><span class="pre">DataArray_t</span></code> children without the restrictions or implicit meanings imposed on these node types at other node locations.</p>
<p><code class="code sidskey docutils literal notranslate"><span class="pre">Ordinal</span></code> is user-defined and has no restrictions on the values that it can contain.
It is included for backward compatibility to assist implementation of the CGNS system into applications whose I/O depends heavily on the numbering of zone interfaces.
Since there are no restrictions on the values contained in <code class="code sidskey docutils literal notranslate"><span class="pre">Ordinal</span></code> (or that <code class="code sidskey docutils literal notranslate"><span class="pre">Ordinal</span></code> is even provided), there is no guarantee that the interfaces for a given zone in an existing CGNS database will have sequential values from 1 to N without holes or repetitions.
Use of <code class="code sidskey docutils literal notranslate"><span class="pre">Ordinal</span></code> is discouraged and is on a user-beware basis.</p>
<dl class="c function">
<dt id="c.PointListSize">
<span class="pre">FUNCTION</span> <code class="sig-name descname"><span class="pre">PointListSize</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.PointListSize" title="Permalink to this definition">¶</a><br /></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return value</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
<dt class="field-even">Dependencies</dt>
<dd class="field-even"><p><code class="code sidskey docutils literal notranslate"><span class="pre">PointRange</span></code>, <code class="code sidskey docutils literal notranslate"><span class="pre">PointList</span></code></p>
</dd>
</dl>
<p><code class="code sidskey docutils literal notranslate"><span class="pre">PointListDonor</span></code>, <code class="code sidskey docutils literal notranslate"><span class="pre">CellListDonor</span></code>, and <code class="code sidskey docutils literal notranslate"><span class="pre">InterpolantsDonor</span></code> require the function <code class="code sidskey docutils literal notranslate"><span class="pre">PointListSize</span></code>, to identify the length of the array. If <code class="code sidskey docutils literal notranslate"><span class="pre">PointRange</span></code> is specified by <code class="code sidskey docutils literal notranslate"><span class="pre">GridConnectivity_t</span></code>, then <code class="code sidskey docutils literal notranslate"><span class="pre">PointListSize</span></code> is obtained from the number of grid points (inclusive) between the beginning and ending indices of <code class="code sidskey docutils literal notranslate"><span class="pre">PointRange</span></code>.
If <code class="code sidskey docutils literal notranslate"><span class="pre">PointList</span></code> is specified by <code class="code sidskey docutils literal notranslate"><span class="pre">GridConnectivity_t</span></code>, then <code class="code sidskey docutils literal notranslate"><span class="pre">PointListSize</span></code> is actually a user input during creation of the database; it is the length of the array <code class="code sidskey docutils literal notranslate"><span class="pre">PointList</span></code> whose elements are also user inputs (by “user” we mean the application code that is generating the CGNS database).</p>
<p>By definition, the <code class="code sidskey docutils literal notranslate"><span class="pre">PointList</span></code> and <code class="code sidskey docutils literal notranslate"><span class="pre">PointListDonor</span></code> arrays have the same size, and this size should be stored along with the arrays in their respective <code class="code sidskey docutils literal notranslate"><span class="pre">IndexArray_t</span></code> structures.
<code class="code sidskey docutils literal notranslate"><span class="pre">PointListSize</span></code> was chosen to be a structure function, rather than a separate element of <code class="code sidskey docutils literal notranslate"><span class="pre">GridConnectivity_t</span></code> for the following reasons: first, it is redundant if <code class="code sidskey docutils literal notranslate"><span class="pre">PointRange</span></code> is specified; and second, it leads to redundant storage if <code class="code sidskey docutils literal notranslate"><span class="pre">PointList</span></code> is specified, since the value of <code class="code sidskey docutils literal notranslate"><span class="pre">PointListSize</span></code> is also stored within the <code class="code sidskey docutils literal notranslate"><span class="pre">PointList</span></code> structure.</p>
<p>This situation has somewhat of a precedent within the SIDS definitions. The structure <code class="code sidskey docutils literal notranslate"><span class="pre">Descriptor_t</span></code> contains a string of unspecified length. Yet in actual implementation, the (string) length is a function of the descriptor string itself and should be stored along with the string.</p>
</dd></dl>

</div>
<div class="section" id="general-interface-connectivity-examples">
<h2><span class="section-number">8.5. </span>General Interface Connectivity Examples<a class="headerlink" href="#general-interface-connectivity-examples" title="Permalink to this headline">¶</a></h2>
<div class="section" id="example-structured-abutting-zones">
<h3><span class="section-number">8.5.1. </span>Example - Structured Abutting Zones<a class="headerlink" href="#example-structured-abutting-zones" title="Permalink to this headline">¶</a></h3>
<p>Say that you have a three-dimensional structured grid. Assume that at the interface between two zones you have the following situation.</p>
<div class="figure align-center" id="id9">
<a class="reference internal image-reference" href="../../_images/cnct_example1.gif"><img alt="Cell faces at interface between two structured zones" src="../../_images/cnct_example1.gif" style="width: 490px;" /></a>
<p class="caption"><span class="caption-text"><em>Example Interface for Generalized Connectivity, Structured Grids</em></span><a class="headerlink" href="#id9" title="Permalink to this image">¶</a></p>
</div>
<p>In this particular example, the patching occurs on a “plane”.
In other words, the two cells in 3-D have faces that abut in a 2-D sense.
It is these faces that we are picturing here. The solid quadrilateral is the donor cell face, and the dashed quadrilateral is the position of the receiving cell face relative to the donor cell.
Note that since this is a 2-D-type of abutting case, one of the indices (in this case <em>i</em> = 20, which represents <code class="code docutils literal notranslate"><span class="pre">imax</span></code>) of the donor cell is constant.
For this example, the point R of the receiver cell is located within the donor cell pictured, and we wish to give the <code class="code sidskey docutils literal notranslate"><span class="pre">CellListDonor</span></code> and <code class="code sidskey docutils literal notranslate"><span class="pre">InterpolantsDonor</span></code> for it.</p>
<p>Because this is a structured grid, the <code class="code sidskey docutils literal notranslate"><span class="pre">CellListDonor</span></code> in this case is given by</p>
<div class="highlight-sids notranslate"><div class="highlight"><pre><span></span><span class="n">CellListDonor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">19</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Here, we are using the <a class="reference internal" href="convention.html#structgrid"><span class="std std-ref">Structured Grid Notation and Indexing Conventions</span></a> that say cell centers, face centers, and edge centers are indexed by the minimum <em>i</em>, <em>j</em>, and <em>k</em> indices of the connecting vertices.</p>
<p>The <code class="code sidskey docutils literal notranslate"><span class="pre">InterpolantsDonor</span></code> defines an interpolation value relative to the cell/element vertices.
In this case, say that the point R is located 0.75 along the <em>j</em>-index direction and 0.45 along the <em>k</em>-index direction.
(It also lies on the <em>i</em> = 20, or <code class="code docutils literal notranslate"><span class="pre">imax</span></code> face.) Thus, in this example:</p>
<div class="highlight-sids notranslate"><div class="highlight"><pre><span></span><span class="n">InterpolantsDonor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.75</span><span class="p">,</span><span class="w"> </span><span class="mf">0.45</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Note that if the donor zone was instead located on an <em>i</em> = 1 (<code class="code docutils literal notranslate"><span class="pre">imin</span></code> face), then the <code class="code sidskey docutils literal notranslate"><span class="pre">CellListDonor</span></code> would be <code class="code docutils literal notranslate"><span class="pre">(1,</span> <span class="pre">10,</span> <span class="pre">2)</span></code> and the <code class="code sidskey docutils literal notranslate"><span class="pre">InterpolantsDonor</span></code> would be <code class="code docutils literal notranslate"><span class="pre">(0.0,</span> <span class="pre">0.75,</span> <span class="pre">0.45)</span></code>.</p>
</div>
<div class="section" id="example-unstructured-abutting-zones-hexa-8-donor-cell">
<h3><span class="section-number">8.5.2. </span>Example - Unstructured Abutting Zones, HEXA_8 Donor Cell<a class="headerlink" href="#example-unstructured-abutting-zones-hexa-8-donor-cell" title="Permalink to this headline">¶</a></h3>
<p>As a second example, assume that you have the same setup as before, but now with a three-dimensional unstructured grid. In this case, we no longer have a 3-D array of indices defining coordinate directions. Instead, we simply have a 1-D list of indices as well as a list of volume (and possibly face) elements composed of those indices. In this example we again are assuming the two zones abut in a 2-D sense. We now have the choice of describing the donor in terms of its volume element or its boundary (face) element, if available. Here in this example, we use the volume element.</p>
<div class="figure align-center" id="id10">
<a class="reference internal image-reference" href="../../_images/cnct_example2.gif"><img alt="Cell faces at interface between two unstructured zones" src="../../_images/cnct_example2.gif" style="width: 490px;" /></a>
<p class="caption"><span class="caption-text"><em>Example Interface for Generalized Connectivity, Unstructured Grids with HEXA_8 Donor Cell</em></span><a class="headerlink" href="#id10" title="Permalink to this image">¶</a></p>
</div>
<p>The <code class="code sidskey docutils literal notranslate"><span class="pre">HEXA_8</span></code> volume element has been appropriately numbered, using the Unstructured Grid Element Numbering Conventions. In this example, it is the 1-2-3-4 face of the volumetric element that is abutting with the other zone (but it could be any of its six faces)</p>
<p>The <code class="code sidskey docutils literal notranslate"><span class="pre">CellListDonor</span></code> in this case is simply given by</p>
<div class="highlight-sids notranslate"><div class="highlight"><pre><span></span><span class="n">CellListDonor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">238</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Using the convention established above for <code class="code sidskey docutils literal notranslate"><span class="pre">HEXA_8</span></code> elements, the <code class="code sidskey docutils literal notranslate"><span class="pre">InterpolantsDonor</span></code> would be</p>
<div class="highlight-sids notranslate"><div class="highlight"><pre><span></span><span class="n">InterpolantsDonor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mf">0.75</span><span class="p">,</span><span class="w"> </span><span class="mf">0.55</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="example-unstructured-abutting-zones-tri-3-donor-cell">
<h3><span class="section-number">8.5.3. </span>Example - Unstructured Abutting Zones, TRI_3 Donor Cell<a class="headerlink" href="#example-unstructured-abutting-zones-tri-3-donor-cell" title="Permalink to this headline">¶</a></h3>
<p>As a third example, assume that you have two zones in a three-dimensional unstructured grid with triangles and quadrilaterals at its boundaries. Here the current zone (made up of quadrilateral faces) is abutting the donor zone (made up of triangular faces) in a 2-D sense.
We again have the choice of describing the donor in terms of its volume element or its boundary (face) element. Here in this example, we use the face element.</p>
<div class="figure align-center" id="id11">
<a class="reference internal image-reference" href="../../_images/cnct_example3.gif"><img alt="Cell faces at interface between two unstructured zones" src="../../_images/cnct_example3.gif" style="width: 390px;" /></a>
<p class="caption"><span class="caption-text"><em>Example Interface for Generalized Connectivity, Unstructured Grids with TRI_3 Donor Cell</em></span><a class="headerlink" href="#id11" title="Permalink to this image">¶</a></p>
</div>
<p>The <code class="code sidskey docutils literal notranslate"><span class="pre">CellListDonor</span></code> in this case is simply given by</p>
<div class="highlight-sids notranslate"><div class="highlight"><pre><span></span><span class="n">CellListDonor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">1893</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Using the convention established above for <code class="code sidskey docutils literal notranslate"><span class="pre">TRI_3</span></code> elements, the <code class="code sidskey docutils literal notranslate"><span class="pre">InterpolantsDonor</span></code> would be:</p>
<div class="highlight-sids notranslate"><div class="highlight"><pre><span></span><span class="n">InterpolantsDonor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mf">0.34</span><span class="p">,</span><span class="w"> </span><span class="mf">0.61</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>In this case the third dimension of the <code class="code sidskey docutils literal notranslate"><span class="pre">InterpolantsDonor</span></code> (although present) is not used, because by default the interpolation is only two-dimensional in the 2-D plane of the donor face.</p>
</div>
</div>
<div class="section" id="grid-connectivity-property-structure-definition-gridconnectivityproperty-t">
<h2><span class="section-number">8.6. </span>Grid Connectivity Property Structure Definition: <code class="docutils literal notranslate"><span class="pre">GridConnectivityProperty_t</span></code><a class="headerlink" href="#grid-connectivity-property-structure-definition-gridconnectivityproperty-t" title="Permalink to this headline">¶</a></h2>
<p><code class="code sidskey docutils literal notranslate"><span class="pre">GridConnectivityProperty_t</span></code> allows the recording of special properties associated with particular connectivity patches.
At the current time, only two properties (<code class="code sidskey docutils literal notranslate"><span class="pre">Periodic_t</span></code> and <code class="code sidskey docutils literal notranslate"><span class="pre">AverageInterface_t</span></code>) are included, but extensions involving other properties may be implemented as additional nodes under <code class="code sidskey docutils literal notranslate"><span class="pre">GridConnectivityProperty_t</span></code> in the future.</p>
<div class="highlight-sids notranslate"><div class="highlight"><pre><span></span><span class="kt">GridConnectivityProperty_t</span><span class="w"> </span><span class="o">:=</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">List</span><span class="p">(</span><span class="w"> </span><span class="kt">Descriptor_t</span><span class="w">  </span><span class="n">Descriptor1</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">DescriptorN</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w">                </span><span class="kr">(o)</span><span class="w"></span>

<span class="w">  </span><span class="kt">Periodic_t</span><span class="w"> </span><span class="n">Periodic</span><span class="w"> </span><span class="p">;</span><span class="w">                                              </span><span class="kr">(o)</span><span class="w"></span>

<span class="w">  </span><span class="kt">AverageInterface_t</span><span class="w"> </span><span class="n">AverageInterface</span><span class="w"> </span><span class="p">;</span><span class="w">                              </span><span class="kr">(o)</span><span class="w"></span>

<span class="w">  </span><span class="k">List</span><span class="p">(</span><span class="w"> </span><span class="kt">UserDefinedData_t</span><span class="w"> </span><span class="n">UserDefinedData1</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">UserDefinedDataN</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w">  </span><span class="kr">(o)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Default names for the <code class="code sidsref docutils literal notranslate"><span class="pre">Descriptor_t</span></code> and <code class="code sidsref docutils literal notranslate"><span class="pre">UserDefinedData_t</span></code> lists are as shown; users may choose other legitimate names. Legitimate names must be unique within a given instance of <code class="code sidskey docutils literal notranslate"><span class="pre">GridConnectivityProperty_t</span></code> and shall not include the names <code class="code sidskey docutils literal notranslate"><span class="pre">Periodic</span></code> or <code class="code sidskey docutils literal notranslate"><span class="pre">AverageInterface</span></code>.</p>
</div>
<p>The <code class="code sidskey docutils literal notranslate"><span class="pre">Periodic_t</span></code> and <code class="code sidskey docutils literal notranslate"><span class="pre">AverageInterface_t</span></code> data structures may be used to record properties associated with periodic interfaces, or interfaces where data is to be averaged in some way, respectively.</p>
<p>The <code class="code sidsref docutils literal notranslate"><span class="pre">UserDefinedData_t</span></code> data structure allows arbitrary user-defined data to be stored in <code class="code sidskey docutils literal notranslate"><span class="pre">Descriptor_t</span></code> and <code class="code sidskey docutils literal notranslate"><span class="pre">DataArray_t</span></code> children without the restrictions or implicit meanings imposed on these node types at other node locations.</p>
<div class="section" id="periodic-interface-structure-definition-periodic-t">
<h3><span class="section-number">8.6.1. </span>Periodic Interface Structure Definition: <code class="docutils literal notranslate"><span class="pre">Periodic_t</span></code><a class="headerlink" href="#periodic-interface-structure-definition-periodic-t" title="Permalink to this headline">¶</a></h3>
<p>The <code class="code sidskey docutils literal notranslate"><span class="pre">Periodic_t</span></code> data structure allows data associated with a periodic interface to be recorded.</p>
<div class="highlight-sids notranslate"><div class="highlight"><pre><span></span><span class="kt">Periodic_t</span><span class="w"> </span><span class="o">:=</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">List</span><span class="p">(</span><span class="w"> </span><span class="kt">Descriptor_t</span><span class="w">  </span><span class="n">Descriptor1</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">DescriptorN</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w">                </span><span class="kr">(o)</span><span class="w"></span>

<span class="w">  </span><span class="kt">DataArray_t</span><span class="o">&lt;</span><span class="kt">real</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">PhysicalDimension</span><span class="o">&gt;</span><span class="w"> </span><span class="n">RotationCenter</span><span class="w"> </span><span class="p">;</span><span class="w">           </span><span class="kr">(r)</span><span class="w"></span>
<span class="w">  </span><span class="kt">DataArray_t</span><span class="o">&lt;</span><span class="kt">real</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">PhysicalDimension</span><span class="o">&gt;</span><span class="w"> </span><span class="n">RotationAngle</span><span class="w"> </span><span class="p">;</span><span class="w">            </span><span class="kr">(r)</span><span class="w"></span>
<span class="w">  </span><span class="kt">DataArray_t</span><span class="o">&lt;</span><span class="kt">real</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">PhysicalDimension</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Translation</span><span class="w"> </span><span class="p">;</span><span class="w">              </span><span class="kr">(r)</span><span class="w"></span>

<span class="w">  </span><span class="kt">DataClass_t</span><span class="w"> </span><span class="n">DataClass</span><span class="w"> </span><span class="p">;</span><span class="w">                                            </span><span class="kr">(o)</span><span class="w"></span>

<span class="w">  </span><span class="kt">DimensionalUnits_t</span><span class="w"> </span><span class="n">DimensionalUnits</span><span class="w"> </span><span class="p">;</span><span class="w">                              </span><span class="kr">(o)</span><span class="w"></span>

<span class="w">  </span><span class="k">List</span><span class="p">(</span><span class="w"> </span><span class="kt">UserDefinedData_t</span><span class="w"> </span><span class="n">UserDefinedData1</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">UserDefinedDataN</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w">  </span><span class="kr">(o)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Default names for the <code class="code sidsref docutils literal notranslate"><span class="pre">Descriptor_t</span></code> and <code class="code sidsref docutils literal notranslate"><span class="pre">UserDefinedData_t</span></code> lists are as shown; users may choose other legitimate names. Legitimate names must be unique within a given instance of <code class="code sidskey docutils literal notranslate"><span class="pre">Periodic_t</span></code> and shall not include the names <code class="code sidskey docutils literal notranslate"><span class="pre">DataClass</span></code>, <code class="code sidskey docutils literal notranslate"><span class="pre">DimensionalUnits</span></code>, <code class="code sidskey docutils literal notranslate"><span class="pre">RotationAngle</span></code>, <code class="code sidskey docutils literal notranslate"><span class="pre">RotationCenter</span></code>, or <code class="code sidskey docutils literal notranslate"><span class="pre">Translation</span></code>.</p>
</div>
<p><code class="code sidskey docutils literal notranslate"><span class="pre">RotationCenter</span></code> is the origin for defining the rotation angle between the periodic interfaces. <code class="code sidskey docutils literal notranslate"><span class="pre">RotationAngle</span></code> defines the angle from the current interface to the connecting interface. If rotating about more than one axis, the rotation is performed first about the x-axis, then the y-axis, then the z-axis. <code class="code sidskey docutils literal notranslate"><span class="pre">Translation</span></code> defines the translation from the current interface to the connecting interface.</p>
<p><code class="code sidsref docutils literal notranslate"><span class="pre">DataClass</span></code> defines the default for the class of data contained in the <code class="code sidskey docutils literal notranslate"><span class="pre">DataArray_t</span></code> structures. If the data is dimensional, <code class="code sidsref docutils literal notranslate"><span class="pre">DimensionalUnits</span></code> may be used to describe the system of dimensional units employed. If present, these two entities take precedence over all corresponding entities at higher levels of the hierarchy, following the <a class="reference internal" href="hierarchy.html#precedence"><span class="std std-ref">standard precedence rules</span></a>.</p>
<p>The <code class="code sidsref docutils literal notranslate"><span class="pre">UserDefinedData_t</span></code> data structure allows arbitrary user-defined data to be stored in <code class="code sidskey docutils literal notranslate"><span class="pre">Descriptor_t</span></code> and <code class="code sidskey docutils literal notranslate"><span class="pre">DataArray_t</span></code> children without the restrictions or implicit meanings imposed on these node types at other node locations.</p>
</div>
<div class="section" id="average-interface-structure-definition-averageinterface-t">
<h3><span class="section-number">8.6.2. </span>Average Interface Structure Definition: <code class="docutils literal notranslate"><span class="pre">AverageInterface_t</span></code><a class="headerlink" href="#average-interface-structure-definition-averageinterface-t" title="Permalink to this headline">¶</a></h3>
<p>The <code class="code sidskey docutils literal notranslate"><span class="pre">AverageInterface_t</span></code> data structure is used when data at the current connectivity interface is to be averaged in some way prior to passing it to a neighboring interface.</p>
<div class="highlight-sids notranslate"><div class="highlight"><pre><span></span><span class="kt">AverageInterface_t</span><span class="w"> </span><span class="o">:=</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">List</span><span class="p">(</span><span class="w"> </span><span class="kt">Descriptor_t</span><span class="w">  </span><span class="n">Descriptor1</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">DescriptorN</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w">                </span><span class="kr">(o)</span><span class="w"></span>

<span class="w">  </span><span class="kt">AverageInterfaceType_t</span><span class="w"> </span><span class="n">AverageInterfaceType</span><span class="w">                        </span><span class="kr">(r)</span><span class="w"></span>

<span class="w">  </span><span class="k">List</span><span class="p">(</span><span class="w"> </span><span class="kt">UserDefinedData_t</span><span class="w"> </span><span class="n">UserDefinedData1</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">UserDefinedDataN</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w">  </span><span class="kr">(o)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Default names for the <code class="code sidsref docutils literal notranslate"><span class="pre">Descriptor_t</span></code> and <code class="code sidsref docutils literal notranslate"><span class="pre">UserDefinedData_t</span></code> lists are as shown; users may choose other legitimate names. Legitimate names must be unique within a given instance of <code class="code sidskey docutils literal notranslate"><span class="pre">AverageInterface_t</span></code> and shall not include the name <code class="code sidskey docutils literal notranslate"><span class="pre">AverageInterfaceType</span></code>.</p>
</div>
<p><code class="code sidskey docutils literal notranslate"><span class="pre">AverageInterfaceType_t</span></code> is a required enumeration data structure that is used to define the type of averaging to be done.</p>
<div class="highlight-sids notranslate"><div class="highlight"><pre><span></span><span class="kt">AverageInterfaceType_t</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">Enumeration</span><span class="p">(</span><span class="w"></span>
<span class="w">  </span><span class="n">AverageInterfaceTypeNull</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">AverageInterfaceTypeUserDefined</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">AverageAll</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">AverageCircumferential</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">AverageRadial</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">AverageI</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">AverageJ</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">AverageK</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p><code class="code sidskey docutils literal notranslate"><span class="pre">AverageAll</span></code> means that the data from the entire current patch is averaged, whereas each of the other choices indicates averaging of the data on the current interface in the indicated direction.
Note that <code class="code sidskey docutils literal notranslate"><span class="pre">AverageI</span></code>, <code class="code sidskey docutils literal notranslate"><span class="pre">AverageJ</span></code>, and <code class="code sidskey docutils literal notranslate"><span class="pre">AverageK</span></code> apply only to structured grids.</p>
<p>The <code class="code sidsref docutils literal notranslate"><span class="pre">UserDefinedData_t</span></code> data structure allows arbitrary user-defined data to be stored in <code class="code sidskey docutils literal notranslate"><span class="pre">Descriptor_t</span></code> and <code class="code sidskey docutils literal notranslate"><span class="pre">DataArray_t</span></code> children without the restrictions or implicit meanings imposed on these node types at other node locations.</p>
</div>
</div>
<div class="section" id="overset-grid-holes-structure-definition-oversetholes-t">
<h2><span class="section-number">8.7. </span>Overset Grid Holes Structure Definition: <code class="docutils literal notranslate"><span class="pre">OversetHoles_t</span></code><a class="headerlink" href="#overset-grid-holes-structure-definition-oversetholes-t" title="Permalink to this headline">¶</a></h2>
<p>Grid connectivity for overset grids must also include “holes” within zones, where any solution states are ignored or “turned off”, because they are solved for in some other overlapping zone.
The structure <code class="code sidskey docutils literal notranslate"><span class="pre">OversetHoles_t</span></code> specifies those points within a given zone that make up a hole (or holes), and applies to both structured and unstructured zones. Grid points specified in this structure are equivalent to those with IBLANK=0 in the PLOT3D format.</p>
<div class="highlight-sids notranslate"><div class="highlight"><pre><span></span><span class="kt">OversetHoles_t</span><span class="o">&lt;</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">IndexDimension</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="o">:=</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">List</span><span class="p">(</span><span class="w"> </span><span class="kt">Descriptor_t</span><span class="w"> </span><span class="n">Descriptor1</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">DescriptorN</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w">                 </span><span class="kr">(o)</span><span class="w"></span>

<span class="w">  </span><span class="kt">GridLocation_t</span><span class="w"> </span><span class="n">GridLocation</span><span class="w"> </span><span class="p">;</span><span class="w">                                      </span><span class="kr">(o/d)</span><span class="w"></span>

<span class="w">  </span><span class="k">List</span><span class="p">(</span><span class="w"> </span><span class="kt">IndexRange_t</span><span class="o">&lt;</span><span class="n">IndexDimension</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">    </span><span class="n">PointRange</span><span class="p">,</span><span class="w"> </span><span class="n">PointRange2</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">PointRangeN</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w">                      </span><span class="kr">(o:r)</span><span class="w"></span>

<span class="w">  </span><span class="kt">IndexArray_t</span><span class="o">&lt;</span><span class="n">IndexDimension</span><span class="p">,</span><span class="w"> </span><span class="n">PointListSize</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">PointList</span><span class="w"> </span><span class="p">;</span><span class="w">       </span><span class="kr">(r:o)</span><span class="w"></span>

<span class="w">  </span><span class="k">List</span><span class="p">(</span><span class="w"> </span><span class="kt">UserDefinedData_t</span><span class="w"> </span><span class="n">UserDefinedData1</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">UserDefinedDataN</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w">  </span><span class="kr">(o)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ol class="arabic simple">
<li><p>Default names for the <code class="code sidsref docutils literal notranslate"><span class="pre">Descriptor_t</span></code>, <code class="code sidsref docutils literal notranslate"><span class="pre">IndexRange_t</span></code>, and <code class="code sidsref docutils literal notranslate"><span class="pre">UserDefinedData_t</span></code> lists are as shown; users may choose other legitimate names. Legitimate names must be unique within a given instance of <code class="code sidskey docutils literal notranslate"><span class="pre">OversetHoles_t</span></code> and shall not include the names <code class="code sidskey docutils literal notranslate"><span class="pre">GridLocation</span></code> or <code class="code sidskey docutils literal notranslate"><span class="pre">PointList</span></code>.</p></li>
<li><p>If <code class="code sidsref docutils literal notranslate"><span class="pre">GridLocation</span></code> is absent, then its default value is <code class="code sidskey docutils literal notranslate"><span class="pre">Vertex</span></code>.</p></li>
<li><p>One of <code class="code sidskey docutils literal notranslate"><span class="pre">PointRange</span></code> and <code class="code sidskey docutils literal notranslate"><span class="pre">PointList</span></code> must be specified, but not both.</p></li>
</ol>
</div>
<p>The location of grid indices specified in <code class="code sidskey docutils literal notranslate"><span class="pre">PointList</span></code> and the <code class="code sidskey docutils literal notranslate"><span class="pre">PointRange</span></code> list is given by <code class="code sidsref docutils literal notranslate"><span class="pre">GridLocation</span></code>.</p>
<p>The grid points making up a hole within a zone may be specified by <code class="code sidskey docutils literal notranslate"><span class="pre">PointRange</span></code> if they constitute a logically rectangular region. If the hole points constitute a (small) set of possibly overlapping logically rectangular regions, then they may be specified by the list <code class="code sidskey docutils literal notranslate"><span class="pre">PointRange</span></code>, <code class="code sidskey docutils literal notranslate"><span class="pre">PointRange2</span></code>, etc. The more general alternate is to use <code class="code sidskey docutils literal notranslate"><span class="pre">PointList</span></code> to list all grid points making up the hole(s) within a zone. Note that using multiple <code class="code sidskey docutils literal notranslate"><span class="pre">PointRange</span></code> specifications may result in a given hole being specified more than once.</p>
<p>The <code class="code sidsref docutils literal notranslate"><span class="pre">UserDefinedData_t</span></code> data structure allows arbitrary user-defined data to be stored in <code class="code sidskey docutils literal notranslate"><span class="pre">Descriptor_t</span></code> and <code class="code sidskey docutils literal notranslate"><span class="pre">DataArray_t</span></code> children without the restrictions or implicit meanings imposed on these node types at other node locations.</p>
<dl class="c function">
<dt>
<span class="pre">FUNCTION</span> <code class="sig-name descname"><span class="pre">PointListSize</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return value</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
<dt class="field-even">Dependencies</dt>
<dd class="field-even"><p><code class="code sidskey docutils literal notranslate"><span class="pre">PointList</span></code></p>
</dd>
</dl>
<p><code class="code sidskey docutils literal notranslate"><span class="pre">OversetHoles_t</span></code> requires one structure function, <code class="code sidskey docutils literal notranslate"><span class="pre">PointListSize</span></code>, to identify the length of the <code class="code sidskey docutils literal notranslate"><span class="pre">PointList</span></code> array. <code class="code sidskey docutils literal notranslate"><span class="pre">PointListSize</span></code> is a user input. (See the discussion on function <span class="xref std std-ref">PointListSize</span>.)</p>
</dd></dl>

</div>
</div>


          </div>
            
  <div class="footer-relations">
    
      <div class="pull-left">
        <a class="btn btn-default" href="grid.html" title="previous chapter (use the left arrow)"><span class="section-number">7. </span>Grid Coordinates, Elements, and Flow Solution</a>
      </div>
    
      <div class="pull-right">
        <a class="btn btn-default" href="boundary.html" title="next chapter (use the right arrow)"><span class="section-number">9. </span>Boundary Conditions</a>
      </div>
    </div>
    <div class="clearer"></div>
  
        </div>
        <div class="clearfix"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="boundary.html" title="9. Boundary Conditions"
             >next</a> |</li>
        <li class="right" >
          <a href="grid.html" title="7. Grid Coordinates, Elements, and Flow Solution"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">CGNS Official Web Site</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../standard.html" >Standard Specification</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="CGNS_SIDS.html" >CGNS/SIDS - Standard Interface Data Structures</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">8. </span>Multizone Interface Connectivity</a></li> 
      </ul>
    </div>
<script type="text/javascript">
  $("#mobile-toggle a").click(function () {
    $("#left-column").toggle();
  });
</script>
<script type="text/javascript" src="../../_static/js/bootstrap.js"></script>
  <div class="footer">
    &copy; Copyright 1991-2020, CGNS Steering Commmittee. Created using <a href="http://sphinx.pocoo.org/">Sphinx</a>.
  </div>
  </body>
</html>